<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TAKO</title>
  
  
  <link href="https://www.hellozuofeng.cn/atom.xml" rel="self"/>
  
  <link href="https://www.hellozuofeng.cn/"/>
  <updated>2021-03-05T19:20:41.208Z</updated>
  <id>https://www.hellozuofeng.cn/</id>
  
  <author>
    <name>老板是只叫JOE的猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GC垃圾收集知识点汇总</title>
    <link href="https://www.hellozuofeng.cn/2020/03/24/gc/"/>
    <id>https://www.hellozuofeng.cn/2020/03/24/gc/</id>
    <published>2020-03-24T13:52:11.000Z</published>
    <updated>2021-03-05T19:20:41.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>此篇文章的诞生是因为每次在新项目上线设置参数时，自己总要回头复习一遍垃圾收集器好来确定新项目上线时该如何选择。正好因为疫情原因，宅家里读完了再版的《深入理解Java虚拟机》（第三版 2019.12月再版）。这次我将常用的垃圾收集器做一个集中汇总总结，方便自己查阅的同时也方便大家查阅。同时在此感谢周志明老师再版《深入理解Java虚拟机》。但是有关书中“3.4.6 并发的可达性分析”这个小章节，我在周老师原文基础上，写了大量自己的理解。因为第一次看第二版时，看到此章节的时候，确实有点稀里糊涂一知半解，现在已经经过自我消化和理解弄懂了。如果有部分同学同样也没看懂的可以仔细阅读本文中<a href="/2020/03/24/gc/#concurrent">并发标记</a>的章节。当然，如果我有理解错误的地方还请大家指正。</p><a id="more"></a><h2 id="何为垃圾"><a href="#何为垃圾" class="headerlink" title="何为垃圾"></a>何为垃圾</h2><p>一个“对象”，我们该如何判断是否是垃圾对象呢？按逻辑来说，我们认为不会再被访问的“对象”就是垃圾对象了，那它就是可以被回收的对象。那JVM要确定一个“对象”不会再被访问，只要确定这个“对象”没有被引用即可。为了确定“对象”是否被引用，出现了不同的确定算法，下面我们分别介绍。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>这个算法实现很简单。在对象中添加一个“引用计数器”，只要“对象”被引用一次，我们就让计数器的值<code>+1</code>。当一个引用失效，就让计数器的值<code>-1</code>。只要计数器的值为<code>0</code>则表示没有任何引用，即表示对象可以被回收了。虽然算法简单粗暴效率高，但是一旦多个“对象”之间相互引用，同时这些对象无其他引用的话，这两个对象将会永远无法被正确回收从而导致了“内存泄漏”。看看下图中的示例大家就明白了。</p><p><img src="/2020/03/24/gc/1.png" alt="1"></p><p>在上图中，<code>A</code>对象被栈中的<code>a</code>变量所引用，<code>D</code>对象被常量池中的<code>d</code>所应用。这两个对象引用计数器的值为<code>1</code>，这是理想情况下正确的引用，对象也被标记为“存活”这没有异议。而对象<code>F</code>没有被任何变量所引用，引用计数器的值是<code>0</code>，它理应是被标记为“死亡”。但是对象<code>B C E</code>三者之间，都是互相引用的，<code>B</code>对象中有变量<code>e</code>引用<code>E</code>对象；<code>E</code>对象中有变量<code>c</code>引用<code>C</code>对象；而<code>C</code>对象中有变量<code>b</code>又引用<code>B</code>对象；而且没有其他变量引用这三个对象。它们形成了一个闭环，并且他们各自的引用计数器的值都是<code>1</code>，会被标记成“存活”，这就造成了“内存泄漏”。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。同样，我们也看看下图的示例。</p><p><img src="/2020/03/24/gc/2.png" alt="2"></p><p>上图中，我们删去了“引用计数器”，并将<code>a</code>和<code>b</code>标记为了“GC Root”。只要在“GC Root”这个引用链上的对象，我们都认为是“存活”对象。相反，不在引用链上的对象，不论你如何被引用都会视为“死亡”对象。这就很号解决了“引用计数法”中对象相互引用的而导致的“内存泄漏”。而我们的JVM标记垃圾对象的算法也就是使用的“可达性分析法”。那问题来了，我们要将哪些对象标记为“GC Root”对象呢？从上图中，已经给出了两个答案。一个是常量池中被引用的对象，二是运行中的线程中被引用的对象。大家想想还没有呢？ 下面我将“GC Root”对象做了总结。  </p><p>GC Root：</p><ul><li>在虚拟机栈(本地变量表)中引用的对象</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象</li><li>在本地方法栈中JNI(Native方法)引用的对象</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象 一些常驻的异常对象(NullPoint,OOM),还有系统类加载器</li><li>反映Java虚拟机部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><h2 id="如何清理"><a href="#如何清理" class="headerlink" title="如何清理"></a>如何清理</h2><p>在弄清楚了如何标记“垃圾”后，我们就得想想如何清理这些被“可达性分析法”标记的“垃圾”对象了。每个垃圾收集器，都具有自己不同的垃圾回收算法，但是有着共同的思想，那就是“分代收集”理论。设计者一般至少会把Java堆划分成新生代和老年代两个区域。在新生代中，大部分对象都会死去，而每次存活的少量对象将会逐步晋升到老年代中。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分“标记”与“清除”两个阶段：首先标记所有需要回收的对象（也可以标记存活对象），标记完成后，统一回收掉所有被标记的对象（标记的是存活对象则清除未被标记的对象）。它是最基础的收集算法，后续的算法大多都是以此算法为基础，对其缺点进行改进的算法。下图为标记-清除算法的执行过程。</p><p><img src="/2020/03/24/gc/3.png" alt="3"></p><p>大家见到上图，应该会发现，这个算法有个明显的缺点：那就是会导致内存空间碎片化。还有一个缺点就是效率不稳定，会随着对象数量的增加而降低效率。</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决标记-清除算法的效率问题，诞生了标记-复制算法。它将可用内存按容量分成大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将“存活”的对象复制到另外一块内存上，再把自己这一块内存一次清理掉。其过程如下图所示。</p><p><img src="/2020/03/24/gc/4.png" alt="4"></p><p>可以看到，上面空间碎片化的问题被标记-复制算法给很好的解决了。但是关于效率问题，如果“存活对象”比较少，那么效率是可以得到保证的。但是存活对象比较多，那么就会将会产生大量的内存间复制的开销。所以此方法比较适用与新生代，因为新生代大部分对象都是朝生夕死的对象。当然，此方法还有一个明显的缺点，就是可用内存只有实际内存的一半，降低了内存使用效率。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>既然标记-复制算法比较适合新生代，那老年代我们应该选择何种算法呢？那么来看看标记-整理算法。其算法也是在标记-清除算法上多做了一件事，那就是清除后进行了内存的整理,将存活的对象向内存空间一端移动。其过程如下。</p><p><img src="/2020/03/24/gc/5.png" alt="5"></p><p>标记-清除与标记-整理算法本质上的差异在于前者是一种非移动式的，后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。那么，我们看看这些商用垃圾收集器都是使用的哪些算法来完成垃圾收集吧。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>上面我们已经介绍了“定位”和“清理”一些理论算法，那我们Hotspot在实现这些算法时，是如何保证高效运行的呢？那么我们现在来介绍一些算法上的实现细节。</p><h3 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h3><p>首先要解决的是，我们每次在定位GC Roots时，如何每次都去扫描整个方法区和所有栈内的引用必将是一个耗时的工作。于是工程师们设计了<code>OopMap</code>的数据结构，在类加载动作完成的时候会记录方法区里的对象引用信息，在即时编译过程中也会在特定位置记录栈中的对象引用信息。这样一来，虚拟机就可以通过<code>OopMap</code>快速定位GC Roots。那么什么是特定位置呢？在阐述特定位置前，我们来谈一个前提。程序在运行中，对象的引用关系是不断变化的，而我们必须保证我们的GC Roots不能遗漏，否则回收掉了我们还需使用的对象程序必将崩溃。所以，现在所有的垃圾收集器在枚举GC Roots时都是会暂停掉我们的用户线程，这就是我们所说的“Stop the world”。回到特定位置的阐述，我们在每个指令的时候都去生成<code>OopMap</code>显然是不合适的，这样不但浪费内存，还占用Cpu资源（引用不断变化）。所以我们生成<code>OopMap</code>应在一个比较“安全”的时段生成是比较合适的，那么这个“安全”的时段我们就称其“安全点”（安全域）。此时用户线程被暂停，引用不发生改变，虚拟机将上次安全点到此次安全点这段时间引用发生的改变来记录<code>OopMap</code>再合适不过了。</p><h3 id="RememberSet"><a href="#RememberSet" class="headerlink" title="RememberSet"></a>RememberSet</h3><p>我们大部分垃圾收集器都使用了分代收集的思想，我们通过<code>OopMap</code>解决了GC Roots的枚举，当我们只回收新生代时，只要在<code>OopMap</code>中找到新生代的引用做为GC Roots，使用“可达性分析”算法定位所有应该存活的对象，再将这些对象复制到一块Survive区域中，同时清空Eden与另一块Survive区域，就完成了一次新生代的垃圾收集。但是有一个问题，那就是如果我们新生代中有些对象没有在GC Roots的引用链上，但在老年代某个对象的引用链上，那我们应该把这个老年代的对象也加入到我们的GC Roots中。那我们是如何记录这种跨代引用关系呢？于是工程师们设计了一个“记忆集”（RememberSet）的数据结构，来记录跨代引用关系。关于记忆集根据其记录精度（字长精度、对象精度、卡精度）多种实现方式，在我们虚拟机中使用的是“卡表”（卡精度）来实现的。卡表中每个元素都是一块内存区域标识，这个内存块叫“卡页”。卡页内只要有一个对象字段存在跨代指针，那么这元素就变脏，值标为0。在垃圾收集的时候，只要把变脏的元素对应的这块内存区域的一起加入GC Roots中一并扫描就能解决跨代收集的问题。但是如何让其变脏？很简单，就是利用赋值时插入“写屏障”来实现。我们可以将“写屏障”看作织入“赋值”操作这个切面的环绕通知，更新“卡表”的工作就在通知中完成。</p><h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><span id="concurrent">并发标记</span></h3><p>我们知道，很多垃圾收集器是在暂停用户线程“Stop the world”的情境下来完成标记，直至CMS收集器的出现。试想一下，用户线程与标记过程一起并发的话，会有两种情况出现：</p><ol><li>应该被标记存活的对象没有标记；</li><li>应该清理的对象被误标记了存活。  </li></ol><p>这两种情况中，第二种还是能够容忍的，只要之后的垃圾收集过程将其清理就行了。但是第一种情况是完全不能接受的。那么我们利用“三色标记”来进行“可达性分析”，看看出现第一种情况有哪些原因。  </p><p>所谓三色标记法：</p><ul><li>白色表示还未被垃圾收集器访问过的对象，所以当垃圾收集线程还未开始执行时，所有对象都是白色；</li><li>黑色表示已经被垃圾收集器访问过的对象，且这个对象中所有引用了的对象都已经被访问，所以黑色对象就是“存活”对象，并且再重新标记过程中不再扫描此对象；</li><li>灰色对象是垃圾收集已经开始访问，但还没有访问完被此对象所引用对象;  </li></ul><p>此处说法与《深入理解Java虚拟机》书中描述有所区别，但实际上是同样的意思，大家将其看做一个过程比较好理解。下面我将画图来说明此过程。</p><p><img src="/2020/03/24/gc/9.png" alt="9"></p><p>上图中所有对象都是白色，此刻是我们开始“标记”线程时，内存的初始状态。现在我们GC线程开始执行“标记”过程，运行到下图状态。  </p><p><img src="/2020/03/24/gc/10.png" alt="10"></p><p>此图状态是垃圾收集器沿着GC Root访问到对象<code>C</code>时的状态。此刻<code>C</code>对象刚开始访问变色为灰色；<code>A</code>和<code>B</code>对象已经访问完毕，且它们对象中引用的其他对象也已经访问（<code>A</code>中引用<code>B</code>，<code>B</code>已经被访问；<code>B</code>中引用了<code>C</code>，<code>C</code>开始了访问），所以<code>A</code>和<code>B</code>变为黑色。  </p><p>如果此刻用户线程修改了引用关系，将<code>B</code>对象添加了引用指向<code>D</code>对象，并且删除了<code>C</code>对象中对<code>D</code>对象的引用，最后完成“可达性分析”遍历，就会导致下图结果。</p><p><img src="/2020/03/24/gc/11.png" alt="11"></p><p>当遍历完成，对象<code>D</code>应该被标记成黑色的“存活”对象，但是由于用户线程操作，使得它将会被错误的清理。大家发现没有，我们现在可以得到结论：导致这样的情况是必须具备两个<span id="condition">条件</span>的：</p><ol><li>黑色对象新建了一个引用指向白色对象。</li><li>这个白色对象必须不在灰色对象引用链中。  </li></ol><p>也就是我们之前两步操作：</p><ul><li>将<code>B</code>对象添加了引用指向<code>D</code>对象</li><li>删除了<code>C</code>对象中对<code>D</code>对象的引用    </li></ul><p><strong>这里大家注意下，我所有操作顺序都是先建立新引用关系，再删除旧引用关系</strong>。这个和《深入理解Java虚拟机》举例子有所不同，如下图。  </p><p><img src="/2020/03/24/gc/16.jpg" alt="16"></p><p>但我个人认为这很重要，我将会在下面一种<a href="#impossible">“不可能发生的情况”</a>（这个不可能不是绝对，有两种情况是有可能的，请大家耐心往下看）中做说明。再回到主题，为了更直观的感受两个条件缺一不可，那么我们分别画图举例说明。</p><p><img src="/2020/03/24/gc/12.png" alt="12"></p><p>上图中，我们只是将<code>B</code>对象添加了引用指向<code>D</code>对象这样的操作。当遍历完成之后，由于<code>C</code>对象还引用着<code>D</code>对象，所以收集器任然可以遍历到<code>D</code>对象，最终<code>D</code>对象还是会被正确标记为黑色。  </p><p><img src="/2020/03/24/gc/13.png" alt="13"></p><p>上图中，我们只是删除<code>C</code>对象中对<code>D</code>对象的引用这个操作。当遍历完成之后，<code>D</code>对象确实也不再存在于GC Roots的引用链中，被标记为白色只是正确删除了这个对象而已。  </p><p>至此，我们得出来的两个条件的结论是否已经成立了？相信有一部分同学，想到了还有一种<span id="impossible">情况</span>，那就是一个原本就不在GC Roots引用链中的对象被一个黑色对象引用了，这种情况有没有？如下图。  </p><p><img src="/2020/03/24/gc/14.png" alt="14"></p><p>上图中，初始内存多出了一个<code>F</code>对象，它并没有在GC Roots的引用链中。当遍历到<code>C</code>对象时，改变引用关系，将黑色对象<code>B</code>添加引用指向<code>F</code>对象。当遍历完成后，本应该被标记为黑色“存活”的对象<code>F</code>还是白色被清除的对象。看上去，这样分析是没有错的，但是大家想一想，这样的情况会出现吗？我先抛出结论，除开两种<span id="special">特例</span>：1.使用<code>Unsafe</code>类；2.这个对象是刚刚新建出来的。除以上两种特殊的情况，这样的情况是不会出现的。下面我们就举个例子来说明为什么不可能，之后再来讨论第二个特例（特例一使用<code>Unsafe</code>类就不讨论了，一般不会使用它来获取内存地址，如果你非要使用出了问题也是自己负责，毕竟别人都告诉你Unsafe了，哈哈哈哈）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MyObject next;</span><br><span class="line">    <span class="keyword">public</span> MyObject other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建了一个<code>MyObject</code>类。这个类中有两个<code>MyObject</code>类型的属性<code>next</code>和<code>other</code>（这里我们只设置两个属性已经够用）。我们在<code>main()</code>方法中，将上图中的<code>A</code>到<code>F</code>对象都创建出来并将其建立引用关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject a = <span class="keyword">new</span> MyObject(); <span class="comment">// A对象</span></span><br><span class="line">    a.next = <span class="keyword">new</span> MyObject(); <span class="comment">// B对象</span></span><br><span class="line">    a.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// C对象</span></span><br><span class="line">    a.next.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// D对象</span></span><br><span class="line">    a.next.next.other = <span class="keyword">new</span> MyObject(); <span class="comment">// E对象</span></span><br><span class="line">    <span class="keyword">new</span> MyObject(); <span class="comment">// F对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家发现了吧，我们的<code>F</code>对象确实会被创建出来，但是它没有赋值给任何变量，这种情况下，请问如何能让<code>B</code>对象来与其建立联系呢？也就是说我们没有变量就不知道<code>F</code>对象的内存地址，不知道内存地址就无法让<code>B</code>对象与其建立引用关系。而我之前为什么要强调先新增黑色对象指向白色对象的引用，再删除灰色对象对此白色对象的引用也是这个道理（如下所见）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject a = <span class="keyword">new</span> MyObject(); <span class="comment">// A对象</span></span><br><span class="line">    a.next = <span class="keyword">new</span> MyObject(); <span class="comment">// B对象</span></span><br><span class="line">    a.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// C对象</span></span><br><span class="line">    a.next.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// D对象</span></span><br><span class="line">    a.next.next.other = <span class="keyword">new</span> MyObject(); <span class="comment">// E对象</span></span><br><span class="line">    <span class="keyword">new</span> MyObject(); <span class="comment">// F对象</span></span><br><span class="line"></span><br><span class="line">    a.next.next <span class="comment">// 这里是获取C对象</span></span><br><span class="line">            .next = <span class="keyword">null</span>; <span class="comment">// 这里是删除C对象与D对象的引用关系</span></span><br><span class="line">    </span><br><span class="line">    a.next <span class="comment">// 这里是获取B对象</span></span><br><span class="line">        .other = a.next.next.next; <span class="comment">// 这里是准备将D对象与B对象建立联系 但是我们发现我们已经找不到D对象的引用（地址）了</span></span><br><span class="line">        <span class="comment">// 此时a.next.next.next 已经是 null 了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里大家应该懂了，为什么要先建立新引用再删除旧引用了吧。  </p><p>回到<code>F</code>对象的问题，有的同学会说那我们将<code>F</code>对象赋值给一个变量不就可以了，如<code>MyObject f = new MyObject()</code>。如果是这样的话，那变量<code>f</code>不应该也会在GC Root中了吗？（如下图）</p><p><img src="/2020/03/24/gc/15.png" alt="15"></p><p>最后，我们再来说说<a href="#special">第二种特殊情况</a>。我们都知道<code>MyObject f = new MyObject()</code>这其实不是一个<strong>原子操作</strong>。也就是说，是有可能出现新建的对象刚创建出来的时候还没有被赋值就发生了GC。此时<code>f</code>变量还没有值（即为<code>null</code>），而<code>F</code>对象也已经在内存中了。那<code>F</code>就会被标记成白色对象清理掉了。其实这样的情况是不会发生的，比如<strong>G1 在基于 SATB 实现的时候，针对新分配的对象，有一个专门的区域，所有该区域的对象都默认被标记为存活</strong>（SATB即原始快照，下面内容会涉及）。如果不是新分配对象，那么它就可以沿用上面陈述的逻辑：要么不在GC Roots的引用链中，我们也无法再找到这个对象的地址（除非使用Unsafe类）再赋值给GC Roots引用链中的对象；要么必定出现在GC Roots引用链中。至此，我们可以完满的证明了我们之前所得出的<a href="#condition">结论</a>。而在《深入理解Java虚拟机》书中归纳的内容即：</p><blockquote><p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色：<br>  *赋值器插入了一条或多条从黑色对象到白色对象的新引用；<br>  *赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p></blockquote><p>接下来，我们只要破坏其中一个条即可。由此分别产生了两个方案：增量更新和原始快照。  </p><ul><li><p>增量更新：这个方案还是很好理解的。它破坏的是第一个条件，黑色对象新增引用为白色对象时，就将这个引用记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。我们还是以上图中的内存布局为例来说明。<br><img src="/2020/03/24/gc/17.png" alt="17"><br>可以看到，我们第一次遍历后，因为<code>B</code>对象新增了白色对象<code>D</code>引用，此时我们就记录下来。等第一遍历完毕，再以记录的这个黑色对象<code>B</code>为根，再遍历一次。从图中我们也可以看出，可以简单理解为<strong>黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了</strong>。</p></li><li><p>原始快照：这个方案相比上一个方案理解起来稍微有点难一点，笔者第一次阅读的时候就没弄懂。此处我会将我的理解写下，供大家参考。这个方案是破坏第二个条件，在有灰色对象删除与白色对象的引用时，我们要将这个引用记录下来。请注意，<strong>这里是将已经删除了的引用记录下来</strong>。比如，我们在以上的例子中，<code>C</code>对象删除了和<code>D</code>对象的引用，那我们记录下这个引用。然后在以<code>C</code>为根重新扫描一次。注意哦，这里实际上已经删除引用关系，可是按我们记录的内容重新扫描的。例子见下图。<br><img src="/2020/03/24/gc/18.png" alt="18"><br>这上面的图和文字大家没理解的话，可以慢慢消化（笔者自我感觉还是已经写的很清楚了）。如果理解了，大家会发现，这不和是我们按照“初始情况”来扫描的结果一样吗（即使改动了应用关系，我们也不理会）？如下图<br><img src="/2020/03/24/gc/19.png" alt="19"><br>没错，这就是原始快照的本意。似乎像是为我们“初始状态”创建了一个快照，不管之后引用关系如何改变，我们只按快照中的引用关系来遍历。但是，这样会出现一个问题，那就是产生“浮动垃圾”。之前我们也交代了，“浮动垃圾”并不是不可容忍的。只要以后的垃圾收集过程能将其清理就行了。至此，我们也可以简单的理解原始快照为<strong>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索</strong>。</p></li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>下面这样图是我们将介绍的垃圾收集器。它们如何有连线则表示可以搭配使用，而所在区域说明了此款收集器的作用域。下面我们将以下收集器做下汇总介绍。</p><p><img src="/2020/03/24/gc/6.png" alt="6"></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到它收集结束。下图是Serial（新生代收集器）搭配Serial Old（老年代收集器）运行流程。</p><p><img src="/2020/03/24/gc/7.png" alt="7"></p><p>虽然Serial已垂垂老矣，但其资源消耗比较小。对于一些内存容量有限，CPU核心数较少的单片机和或者是一些客户端的微服务来说，Serial仍然不失为一个好的选择。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为与Serial收集器完全一致。下图是ParNew（新生代收集器）搭配Serial Old（老年代收集器）运行流程。</p><p><img src="/2020/03/24/gc/8.png" alt="8"></p><p>ParNew收集器多数情况下是与CMS收集器搭配使用。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个并行的多线程新生代收集器，采用“标记-复制”算法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;此篇文章的诞生是因为每次在新项目上线设置参数时，自己总要回头复习一遍垃圾收集器好来确定新项目上线时该如何选择。正好因为疫情原因，宅家里读完了再版的《深入理解Java虚拟机》（第三版 2019.12月再版）。这次我将常用的垃圾收集器做一个集中汇总总结，方便自己查阅的同时也方便大家查阅。同时在此感谢周志明老师再版《深入理解Java虚拟机》。但是有关书中“3.4.6 并发的可达性分析”这个小章节，我在周老师原文基础上，写了大量自己的理解。因为第一次看第二版时，看到此章节的时候，确实有点稀里糊涂一知半解，现在已经经过自我消化和理解弄懂了。如果有部分同学同样也没看懂的可以仔细阅读本文中&lt;a href=&quot;/2020/03/24/gc/#concurrent&quot;&gt;并发标记&lt;/a&gt;的章节。当然，如果我有理解错误的地方还请大家指正。&lt;/p&gt;</summary>
    
    
    
    <category term="Java虚拟机" scheme="https://www.hellozuofeng.cn/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://www.hellozuofeng.cn/tags/JVM/"/>
    
    <category term="GC" scheme="https://www.hellozuofeng.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>源码解读——HashMap</title>
    <link href="https://www.hellozuofeng.cn/2018/06/14/HashMap/"/>
    <id>https://www.hellozuofeng.cn/2018/06/14/HashMap/</id>
    <published>2018-06-14T13:08:36.000Z</published>
    <updated>2021-03-01T10:39:15.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的<code>HashMap</code>和<code>JDK1.8</code>之前的<code>HashMap</code>来做比较。今天我将通阅读基于<code>JDK1.8</code>的<code>HashMap</code>与<code>JDK1.7</code>的<code>HashMap</code>的源码来与大家做一个分享。  </p><p>我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。<strong>这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。</strong>当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳<code>JDK1.8</code>中的<code>HashMap</code><a href="/2018/06/14/HashMap/#sum">总结</a>查看，或者JDK1.8与JDK1.7的<a href="/2018/06/10/HashMap/#sums">异同</a>查看对比。  </p><p>最后，我的<a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a>系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。<br>那么，废话就不说了，大家跟着我一起来阅读源码吧。</p><a id="more"></a><h2 id="JDK1-8中的HashMap"><a href="#JDK1-8中的HashMap" class="headerlink" title="JDK1.8中的HashMap"></a>JDK1.8中的HashMap</h2><p>每个人都又不同的阅读耐心。为了能让耐心不够的同学，可以在更有效的时间内记住更重要的内容，所有我们从优化更好的、使用率更高的1.8版本的HashMap开始阅读！  </p><p>那么我们来<code>new HashMap()</code>，跟着无参构造函数进入源码。</p><h3 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a>new HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在<span id="con">无参构造函数</span>中，源码只是设置了属性<code>loadFactor</code>的值为一个<code>DEFAULT_LOAD_FACTOR</code>的常量。此时我们碰到了第一个属性和第一个常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 第一个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 第一个常量 </span></span><br></pre></td></tr></table></figure><p>可以看出这<code>DEFAULT_LOAD_FACTOR</code>常量是<code>loadFactor</code>属性的默认值（<code>0.75</code>），但暂时没有其他信息，让我们记住这个属性和常量的值。既然源码只是初始化了一下一个属性，那么我进入<code>put()</code>方法。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>put()</code>方法中，我们看到<code>key</code>被传入了<code>hash()</code>方法。显然这是一个获取<code>key</code>hash值的算法。那么我们来看1.8中是如何计算key的hash值的。  </p><h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a><span id="hash">hash()</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// key==null时返回hash值0，否则调用hashCode()获取hash值并异或此hash高位并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>HashMap</code>中的静态的不可重写的方法，返回一个<code>int</code>类型的hash值。当传入的<code>key</code>是<code>null</code>时，直接返回了值<code>0</code>。由此我们可以得到源码阅读的第一条结论，<strong>HashMap在jdk1.8中可以存放key为null的键值对，且key为null时的hash值即<code>0</code>。</strong><br>继续向下看，源码中，<code>key</code>调用了<code>Object</code>的<code>hashCode()</code>方法获取到了一个Hash值，再和此hash值的<a href="#high">高位</a>进行了一个异或<code>^</code>运算。这样做的目的是什么呢？为什么不直接返回<code>Object</code>中<code>hashCode()</code>的值呢？这里我们暂时记住它，我们回到<code>put()</code>方法继续往下看，源码中调用了<code>putVal()</code>方法。</p><blockquote><p><span id="high"><code>&gt;&gt;&gt; 16</code></span>表示无符号右位移16位运算，<code>int</code>类型有32位的长度，右位移16位即截取了此<code>int</code>值的左边16位的值，而所谓“左边16位”是口语化的说法，身为程序员，应该知道，平时我们称此为“高位”，而对应的“右边16位”我们称“低位”，如果要截取低位的值，可以使用<code>&amp; 0x0000FFFF</code>的运算获得。这样的“位运算”是基础知识，此篇文章就不再详细介绍了，如果不懂可以自行google或baidu。  </p></blockquote><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//判断table是否被初始化</span></span><br><span class="line">        <span class="comment">// table未被初始化时</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// resize()方法中初始化Node数组</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// hash值与数组长度模获取下标，再获获取tab对应此下标的Node</span></span><br><span class="line">            <span class="comment">// 当此下标下的Node为null，已进加入元素（key,value）创建Node并赋值到此下标</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当此下标的Node不为空时</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断获取到的Node中的元素与新加入的元素（key,value）是否为同一元素</span></span><br><span class="line">                e = p; <span class="comment">// 当此Node中元素与新加入元素为同一元素时，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断获取到的Node是都为 红黑树结构</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">// 如果获取的Node是红黑树结构时，将新加入的元素创建TreeNode并添加至红黑树，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 当此Node为链表结构且Node中元素与新加入的元素不为同一元素时</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 循环此Node链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//判断链表是否含有后继节点（next是否为null）其用意是判断该节点是否已经是尾部节点</span></span><br><span class="line">                        <span class="comment">// 当next=null时，无后继节点时，即当前节点已经是尾节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 将新加入的元素创建新Node赋值给当前Node（尾节点）的next，即让新加入的元素成为尾节点（尾插法）。</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st 判断链表的长度是否超过阈值（默认值8）</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">// 当链表的长度超过阈值8 则将整个链表转成红黑树结构</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断获取到的Node中的next元素与新加入的元素（key,value）是否为同一元素</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key 如果是加入元素是新构造的节点时 即此链表或红黑树中没有与新加入元素相同元素</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount; <span class="comment">// 每次putVal 此值必定+1 表示HashMap被修改从次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断当前HashMap的容量size 是否大于阈值threshold </span></span><br><span class="line">            resize(); <span class="comment">// 当容量过大时发生扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>putVal()</code>方法，代码读到<code>if ((tab = table) == null || (n = tab.length) == 0)</code>（行号4），第二个属性<code>table</code>出现，此属性的类型是一个静态内部类<code>Node&lt;K,V&gt;</code>的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 第二个属性table 链表数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类，链表的节点类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 省略set、get等方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很显然，这个静态内部类是一个链表的节点类型，并且此链表是一个单向链表（只有next，无prev）。那此行代码的用意就在于判断<code>table</code>是否已经被初始化了（<a href="#transient">transient关键字的意义</a>）。记得吗？我们在<a href="#con">构造函数</a>中，只初始化了一个参数<code>loadFactor = DEFAULT_LOAD_FACTOR = 0.75f</code>，那么代码到<code>n = (tab = resize()).length</code>（行号6）。<code>resize()</code>方法应该会初始化节点数组<code>node&lt;K,V&gt;[] table</code>（从代码逻辑可以看出，不初始化下面的逻辑将无法继续）。而这个<code>table</code>就是一个链表数组，那么，我们可以暂时得到结论：<strong>HashMap是数组加链表的数据结构，并且这个数组是在第一次put()时才被初始化</strong>。我们先把<code>resize()</code>方法放一放，继续向下读。  </p><blockquote><p>被<span id="transient"><code>transient</code></span>关键字修饰的属性不会别序列化。</p></blockquote><p>代码来到<code>if ((p = tab[i = (n - 1) &amp; hash]) == null)</code>（行号7），这里是使用元素的<code>hash</code>值来计算数组下标。按照我们平时的逻辑，我们一般会用<code>hash</code>值去与数组长度<code>n</code>取模来获取定位此元素在数组中的位置，这样也利用了<code>hash</code>值且不会发生<code>ArrayIndexOutOfBoundsException</code>（数组下标越界）。而源码中是<code>(n - 1) &amp; hash</code>方式来定位下标。其实，源码是使用了效率更高的位运算方法来<a href="#qumo">取模</a>的。现在我们知道了如何定位数组下标的，回到<a href="#hash">之前</a><code>hash()</code>方法。为什么要用高位去与上低位呢？目的是为了减少哈希碰撞（降低下标值相等的概率）。试想一下，如果我们获取到是<code>hash</code>值都是<code>1101 0000</code>、<code>1000 0000</code>、<code>1010 0000</code>等这种低位值都“相似”的值，而这些值去与上同一个值（数组长度）且这个值也不大（比如<code>0000 1010</code>），势必我们得到的结果就会一样了，即发生了哈希碰撞。为了减少哈希碰撞，那么，我们就得想办法，让高位也参与到运算中。<strong>因此，源码中使用让低位与上高位这样的操作，目的是让高位参与到取模运算中来，以避免哈希碰撞</strong>。  </p><blockquote><p><span id="qumo">取模</span>小技巧 <code>val % 2^n = val &amp; (2^n - 1)</code>。在<code>HashMap</code>中，数组的长度是必定是2^n。</p></blockquote><p>我们继续往下读，<code>tab[i] = newNode(hash, key, value, null)</code>（行号9）。这行代码就是当此下标元素为空时，直接将我们这个新put进来的元素构造成<code>Node&lt;K,V&gt;</code>赋值给了此下标（情况如下图）。<br><img src="/2018/06/14/HashMap/1.png" alt="1"><br>那么，当我们此下表下已经存在链表了，会是什么情况呢？<span id="1314"><code>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code>（行号13和14）</span>，如果存在链表了，会先判断我们新加入的元素和此链表的第一个<code>Node&lt;K,V&gt;</code>节点是否为同一元素，即判断它们的Hash值和key是否一致。如果新加入的元素是同一元素，那么很好办，将新值value替代老值即可。  </p><p>代码继续向下<code>else if (p instanceof TreeNode)</code>（行号16），如果不为同一元素的话，会去判断是否为<code>TreeNode&lt;K,V&gt;</code>类型。又出现了一个新的静态内部类<code>TreeNode&lt;K,V&gt;</code>，我们来看看这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// 省略构造、get、set等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>left right red</code>这三个属性，我们基本能看出这个类型就是一个红黑树的节点类型了。那么，我们需要修改下之前的结论：<strong>HashMap是数组加链表再加红黑树的数据结构</strong>。如果是<code>TreeNode&lt;K,V&gt;</code>，则<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>（行号17），<code>putTreeVal()</code>方法中无非也是判断是否存在相同元素，存在相同元素就替代值，不存在就插入到这个红黑树（如下图所示）。至于，这个链表是何时转变成红黑树的呢？我们带着这个疑问继续往下读。<br><img src="/2018/06/14/HashMap/2.png" alt="2">  </p><p>如果这时的结构是链表呢？那我们就应该循环这个获取这个链表里的每个<code>Node&lt;K,V&gt;</code>来与新加入的元素进行比较，如果链表中一旦有与新加入元素相同的元素，就和<a href="#1314">之前代码</a>（行号13和14）一样的逻辑，替代其值就行了。源码也显示，我们的想法是没有错的。<code>for (int binCount = 0; ; ++binCount)</code>（行号19）开始循环这个链表，但源码中是获取的当前节点的后继节点<code>if ((e = p.next) == null)</code>（行号20）,因为在之前的逻辑中，我们已经对头节点进行了处理了。这样一来这句代码的用意就是先判断了当前节点是否是尾节点，如果当前节点是尾节点了，就直接将新加入的节点加入到尾节点后面即可，<code>p.next = newNode(hash, key, value, null)</code>（行号22）。那么我们现在又可以得到一个结论：<strong>HashMap中加入新的链节点，是采用的尾插法</strong>。（如下图所示）<br><img src="/2018/06/14/HashMap/3.png" alt="3">    </p><p>代码来到<code>if (binCount &gt;= TREEIFY_THRESHOLD - 1)</code>（行号23），这是里出现了我们第二个常量<code>TREEIFY_THRESHOLD = 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>如果<code>Node&lt;K,V&gt;</code>数量大于等于这个值<code>-1</code>时（为什么需要<code>-1</code>呢？因为，我们是获取的next，是从第二个节点开始计算的），会调用<code>treeifyBin(tab, hash)</code>（行号24）方法。从方法的名字上我们就可以判断，这是一个将链表变形成红黑树的方法。也就是说，当链表的长度超过<code>TREEIFY_THRESHOLD = 8</code>时，链表就会生成红黑树了。这里我们又可以出一个结论：<strong>TREEIFY_THRESHOLD常量是链表转红黑树的阈值，当链表长度超过8时，链表将会变形成红黑树结构</strong>。  </p><p>代码继续往下读，接下来的就是与行号13、14相同的逻辑了（行号27和28）。之后，我们判断了下是否为非新加入元素，而只是替换值，如果是替换值返回被替换的值（行号33到38）。然后代码来到<code>++modCount</code>（行号41），出现了一个新的值属性<code>modCount</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>就目前的信息，我们只知道如果调用了<code>putVal()</code>方法，此值必定加1，再无其他信息，等获取到更多信息我们再来定义这个值的意义。然后又出现了两个新的属性<code>size</code>与<code>threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>其中<code>size</code>很好理解，这就是当前<code>HashMap</code>的大小。至于<code>threshold</code>属性，代码<code>if (++size &gt; threshold)</code>（行号42）中的意思是，如果当前<code>HashMap</code>大小超过了这个值的时候，就会调用<code>resize()</code>方法。之前我们没有进入这个方法查看过，知道它一定会初始化<code>table</code>属性，这里又一次调用了这个方法，会不会这个方法就是修改<code>table</code>的方法呢？换句话说，这个方法就是修改数组的方法。我们接下来，进入<code>resize()</code>一探究竟。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; </span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 获取当前数组长度 数组未初始化时长度为0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// 获取当前数组长度阈值 threshold int属性初始化值也为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">// 声明新数组长度与阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断当前数组长度是否&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 此处判断当前数组大小是否超过MAXIMUM_CAPACITY（极限长度）</span></span><br><span class="line">            threshold = Integer.MAX_VALUE; <span class="comment">// 令数组阈值等于极限阈值长度 即Integer最大长度</span></span><br><span class="line">            <span class="keyword">return</span> oldTab; <span class="comment">// 返回当前数组 即不再进行扩容操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 当前数组的长度&lt;&lt;1(左位移1位) 即乘2操作 令新数组两倍扩容 并判断是否小于MAXIMUM_CAPACITY（极限长度）</span></span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 判断数组当前的长度是否&gt;=数组初始化长度(DEFAULT_INITIAL_CAPACITY = 16) </span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 新数组的阈值同样乘以2 即新数组阈值也成倍扩大</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">// 当前数组长度=0 但数组阈值&gt;0 此情况是调用的带参构造时 会令threshold=初始化长度 但数组并未初始化 则让新数组长度=threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults 当前数组长度=0且当前数组阈值=0 即数组未被初始化时</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 初始化数组的大小等于 DEFAULT_INITIAL_CAPACITY = 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 初始化数组的阈值 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY = 0.75 * 16 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 此处同为带参构造时的逻辑延续 上面只令newCap = oldThr 并未初始化newThr的值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor; <span class="comment">// 令新数组阈值 = 新数组长度 * 扩容因子0.75（loadFactor = DEFAULT_LOAD_FACTOR）</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 令当前阈值=新数组的阈值（即将扩容的数组）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 初始化新数组</span></span><br><span class="line">    table = newTab; <span class="comment">// 令当前数组=新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 判断当前数组是否为null 当前数组只有未被初始化时才会=null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 循环数组</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断此下标j下的元素是否=null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 判断此下标下的元素是否存在后继元素 即判断是否只有一个头节点元素</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 重新根据hash值计算对应新数组中的位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断节点是否为红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">// 分裂红黑树</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order 分裂链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看这个方法是如何初始化<code>table</code>的。先将和初始化<code>table</code>无关的代码省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>table=null</code>，可以得出<code>oldCap = 0</code>。又因<code>int</code>类型属性默认值为<code>0</code>可以得出<code>oldThr = 0</code>。所以代码不会进入<code>oldCap &gt; 0</code>，也不会进入<code>oldThr &gt; 0</code>，只会进入<code>else</code>的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新的常量<code>DEFAULT_INITIAL_CAPACITY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>而代码逻辑是令<code>newCap</code>等于了这个常量<code>16</code>，令<code>newThr</code>等于了我们之前在构造方法里使用过的常量<code>DEFAULT_INITIAL_CAPACITY = 0.75f</code>乘以了这个常量，结果为<code>0.75 * 16 = 12</code>。代码继续向下来到<code>threshold = newThr</code>，即令<code>threshold</code>属性等于刚才计算的值<code>12</code>。还记得吗？我们进入<code>resize()</code>方法，除了初始化功能外，还会有一个判断，就是和这个属性有关联的<code>++size &gt; threshold</code>，当整个<code>HashMap</code>的元素总量大于这个值时，也会进入。我们先把初始化代码读完，之后再来看看这个情况下进入<code>resize()</code>方法都干了些什么。代码继续到<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>，很显然，这里初始化了<code>table</code>数组了，并以<code>newCap</code>为数组长度，那么我们是不是可以得到一个结论：<strong>DEFAULT_INITIAL_CAPACITY常量是HashMap中Node数组的默认初始化长度</strong>。最后返回了初始化的这个数组，至此初始化逻辑过了一遍。  </p><p>接下来，我们看看<code>resize()</code>方法的全貌，当已经初始化了<code>table</code>并且<code>++size &gt; threshold</code>时，逻辑是怎么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随代码进入<code>if (oldCap &gt; 0) &#123;&#125;</code>中的逻辑。先是判断了<code>if (oldCap &gt;= MAXIMUM_CAPACITY)</code>，这里又出现一个常量，从名字就能推断，<strong>MAXIMUM_CAPACITY是数组长度的极限长度</strong>，是一种极端情况的处理。下面的逻辑是让<code>threshold = Integer.MAX_VALUE</code>并直接返回了<code>table</code>，老规矩先记住这里之后再来总结。代码向下<code>else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</code>，这里让<code>newCap</code>即将新建的数组的长度等于了当前数组的长度乘以二（<code>&lt;&lt; 1</code>即乘2操作）。又执行<code>newThr = oldThr &lt;&lt; 1;</code>令<code>newThr</code>的值也等于了<code>oldThr</code>乘以2。之后，同样是<code>threshold = newThr;</code>，并创建数组<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>。这不就是创建了一个容量为原数组两倍的新数组吗？哦，原来<code>resize()</code>方法是一个数组的扩容方法，当<code>++size &gt; threshold</code>时进行扩容，那<code>threshold</code>属性就“扩容”触发的“阈值”了，接下来<code>if (oldTab != null)</code>里面的逻辑，就上让原来的数组元素转移到新的数组中的逻辑。我们此时，是不是可以得到这样的结论：<strong>threshold属性是触发扩容的“阈值”属性，它的初始化默认值为 DEFAULT_INITIAL_CAPACITY(0.75) x DEFAULT_INITIAL_CAPACITY(16)即12。而DEFAULT_INITIAL_CAPACITY常量则是扩容“阈值”的因子。而扩容的方式就是将数组长度成倍增长。</strong>  之后的代码逻辑，无非就是将原先的数组里面的元素转移到新数组中，最后返回这个新数组。  </p><p>至此，我们将<code>resize()</code>方法也过了一遍了，它就是我们<code>HashMap</code>中数组的扩容方法。这里，我们有必要把数组扩容后每个元素的对应的数组下标再来进行下分析。我们现在知道了扩容过程就是将数组容量翻倍，那原来对应某个下标的元素也将以<code>hash &amp; n - 1</code>方式取模重新计算下标。试想一下，如果原数组大小为<code>16</code>，<code>hash</code>值为<code>4</code>与<code>hash</code>值为<code>20</code>的元素必定会在同以数组下标<code>4</code>的链表上；当扩容到<code>32</code>时，<code>hash</code>值为<code>4</code>的元素计算的下标仍然为<code>4</code>，而<code>hash</code>值为<code>20</code>的元素的下标变成了<code>20</code>。发现了吗？<code>20</code>正好比<code>4</code>大一个扩容量<code>16</code>。其实发生扩容后，如果不在原下标下了，那么此元素的下标正好变为了<code>原下标 + 扩容量</code>。如果我们动态化的看，扩容就像是在创建一个一样长度的数组，将同一下标下的元素分成两份，一遍放一份，然后将数组拼接起来。或者可以理解为将其中一份往右移动<code>扩容量</code>的长度（如下图所示）。<br><img src="/2018/06/14/HashMap/4.png" alt="4"><br>但是，我们发现源码中似乎和我们设想的有所不同。它并没有用<code>hash &amp; newCap - 1</code>，这样的逻辑来分裂链表，我们看到的逻辑是<code>if ((e.hash &amp; oldCap) == 0)</code>的判断，为<code>0</code>则不下标不动，反之下标为<code>j + oldCap</code>。这样做的意义和<code>hash &amp; newCap - 1</code>的结果不会有出入？为什么？我们验证一下。首先有个前提，我们已知<code>HashMap</code>中的数组长度永远是<code>2^n</code>并且一次扩容是扩大一倍，可以理解为左位移一位即<code>&lt;&lt; 1</code>。我们用上图中的数据来做个比较，<code>4 - 1 = 3</code>转二进制为<code>11</code>，<code>8 - 1 = 7</code>转二进制为<code>111</code>，这两个值不同之处在于，<code>7</code>比<code>3</code>多出一个高位值。而恰恰所有<code>2^n - 1</code>的值都是一串<code>1</code>，比如<code>16 - 1 = 15 = 1111</code>，<code>32 - 1 = 31 = 11111</code>，那么每次扩容重新计算下标时，我们<code>hash</code>永远不变，<code>newCap</code>又永远是在<code>oldCap</code>的基础上高位多一个<code>1</code>。而对应的下标“动”或“不动”，只要看<code>hash</code>值中对应多出的这个高位值<code>1</code>是否为<code>0</code>即可，为<code>0</code>下标不变，反之下标<code>+n</code>。理解了这里，就很好理解为什么用<code>&amp; oldCap == 0</code>来判断了，因为<code>oldCap</code>恰恰就是对应这个高位值。还是拿上面的数据举例，<code>oldCap = 4</code>转二进制<code>0100</code>，是不是<code>0011</code>与<code>0111</code>多出的这个高位？所有，我们用<code>if ((e.hash &amp; oldCap) == 0)</code>的判断就能推倒出这个元素该不该“移动”了。下面的表格是拿上面的数据填充的，可以加深大家的理解。</p><p>| 数值 | 二进制 | 7(newCap=8)对比3(oldCap=4)多出的高位值 | &amp;3的结果 | &amp;7的结果 | 对应的高位值 | “动”否<br>| :-: | :-: | :-: | :-: | :-: | :-: |<br>| 47 | 0010 1111 | 0100 = 4(oldCap) | 0010 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0010 1111 &amp; 0000 0111 = 000 0111 = 7 | 101[1]11 | Yes |<br>| 15 | 0000 1111 | 0100 = 4(oldCap) | 0000 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0000 1111 &amp; 0000 0111 = 0000 0111 = 7 | 0000 1[1]11 | Yes |<br>| 3 | 0000 0011 | 0100 = 4(oldCap) | 0000 0011 &amp; 0000 0011 = 0000 0011 = 3 | 0000 0011 &amp; 0000 0111 = 0000 0011 = 3 | 0000 0[0]11 | No |<br>| 99 | 0110 0011 | 0100 = 4(oldCap)  | 0110 0011 &amp; 0000 0011 = 0000 0011 = 3 | 0110 0011 &amp; 0000 0111 = 0000 0011 = 3 | 0110 0[0]11 | No |<br>| 31 | 0001 1111 | 0100 = 4(oldCap) | 0001 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0001 1111 &amp; 0000 0111 = 0000 0111 = 7 | 0001 1[1]11 | Yes |</p><p>到这里我们还只是讲了链表结构的在扩容后的变化，红黑树结构在扩容后的变化应该与链表时差不多的。我们已经知道链表在超过<code>TREEIFY_THRESHOLD = 8</code>时，会转化为红黑树，那红黑树扩容后，也会分为两部分，那就表示红黑树会被分成两颗树，是这样的吗？那就需要我们进入<code>split()</code>方法中一探究竟了。</p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码前面声明<code>TreeNode&lt;K,V&gt;</code>（行号4，5）来看，我们很容易就得到了结论，确实是将这个树一分为二了。和链表的扩容之后分配元素的逻辑也是是相同的<code>if ((e.hash &amp; bit) == 0)</code>（行号10），只要证明<code>bit</code>的值是否为<code>oldCap</code>即可。代码回到<code>resize()</code>的38行，<code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code>，没错，传入的就是<code>oldCap</code>的值。代码往下看，分裂成两个树结构后，分别对“两棵树”做了判断，代码行号28-29和37-38。此处又出现了一个新的常量<code>UNTREEIFY_THRESHOLD</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>如果长度<code>&lt;= UNTREEIFY_THRESHOLD = 6</code>这个值，将会调用<code>untreeify()</code>方法。从方法名和返回值就可以看出，这就是树结构转链表的方法，那么我们就能推导出结论：<strong>UNTREEIFY_THRESHOLD常量是红黑树最小元素阈值，当红黑树元素小于等于6时红黑树又会转链表。</strong> 那如果长度<code>&gt; UNTREEIFY_THRESHOLD = 6</code>，调用<code>treeify()</code>方法。这个方法是真正转红黑树的方法，看下面的代码逻辑也可以看出，这些处理只是将<code>TreeNode&lt;K,V&gt;</code>串起来而已。如果是这样，那么我前面没进入阅读的方法<code>treeifyBin()</code>又是什么方法呢？我们大概猜得到，应该是将<code>Node&lt;K,V&gt;</code>转成<code>TreeNode&lt;K,V&gt;</code>的方法，并且也只是将<code>TreeNode&lt;K,V&gt;</code>串了起来，然后方法内部再调用<code>treeify()</code>方法将串好的<code>TreeNode&lt;K,V&gt;</code>真正转为红黑树。那么进入<code>treeifyBin()</code>方法验证下我们的想法。</p><h3 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a>treeifyBin()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// 数组长度小于MIN_TREEIFY_CAPACITY 64时，不会转红黑树，只是扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入方法，我们就看到了最后一个常量<code>MIN_TREEIFY_CAPACITY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>代码<code>if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</code>（行号3）是将数组的长度与此常量进行了对比判断，即当数组的长度不满足<code>64</code>时不会进行链表转红黑树，而且尽量使数组扩容来解决链表长度过长的问题。之后的逻辑就非常清晰了，就是我们说的，调用<code>treeify()</code>方法转成红黑树结构。只是<code>64</code>长度的数组，看上去好像挺大的，其实我只进行两次扩容就达到了这个值了。默认长度是<code>16</code>，扩容一次翻倍变<code>32</code>，再一次就是<code>64</code>了。  </p><p>至此，我们已经将<code>put()</code>方法涉及到的绝大部分内容，包括方法、常量、属性等等都过了一遍了，<code>HashMap</code>重点知识基本上都点到了，以防有遗漏，我们还是看看<code>remove()</code>方法吧。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>put()</code>方法类似，先根据<code>key</code>计算了<code>hash</code>，再调用了<code>final</code>修饰的<code>removeNode()</code>方法。<code>hash()</code>方法我们之前分析过了，直接进入<code>removeNode()</code>看看吧。</p><h3 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; <span class="comment">// 判断当前数组不为null</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断需要移除的元素的key对应的数组的下标链表或红黑树元素不为null</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; </span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断此下标下的链表或红黑树的首节点是否是需要移除的元素</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果首节点不是需要移除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断此下标下的元素集合类型是否是红黑树</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); <span class="comment">// 获取红黑树中对应的此key的节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 如果是链表类型 循环链表 获取链表中对应的此key的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 记录下一个节点的前置prev节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || <span class="comment">// 判断是否找到此key对应的节点</span></span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断此节点的类型是否为红黑树</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable); <span class="comment">// 为红黑树时调用红黑树的移除方法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 判断此节点是否为链表首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 如果是链表首节点直接将此节点next节点赋予此下标</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;<span class="comment">// 非链表首节点则p为此节点前置节点 将前置节点的next指向此节点的next</span></span><br><span class="line">            ++modCount; <span class="comment">// 操作次数+1</span></span><br><span class="line">            --size; <span class="comment">// HashMap的大小-1</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中先是判断了此时<code>HashMap</code>中的数组<code>table</code>是否为空<code>(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0</code>（行号4），再判断了需要移除的这个<code>key</code>计算出来的下标下的元素是否为空<code>(p = tab[index = (n - 1) &amp; hash]) != null</code>（行号5）。如果有一者为空，表示此<code>key</code>无映射的元素，直接返回空。如果这两者都不为空，那么我们就需要在这个链表或者说是红黑树中找到这个key映射的元素。代码行号<code>12</code>是在红黑树结构中找到此元素，代码行号<code>14-23</code>是在链表结构中找到此元素。之后再判断是否找到了此元素（行号25、26）。如果没找到，则还是返回空。找到了此元素的话，再判断这个元素类型是链表还是红黑树。是红黑树则调用<code>removeTreeNode()</code>（行号28）移除此元素。是链表的话，则判断是否为头节点。如果是链表头节点则直接将此节点的后继节点<code>next</code>放到此下标下即可<code>tab[index] = node.next;</code>（行号30），但如果不是头节点，就会将记录的此节点的前置节点的<code>next</code>指向此节点的<code>next</code>来完成删除<code>p.next = node.next;</code>（行号32）。  </p><p>之后，我们又看到<code>modCount</code>属性和<code>size</code>属性，分别做了<code>+1</code>处理和<code>-1</code>处理。移除元素<code>size-1</code>很好理解，那<code>modCount</code>表示什么呢？不论是<code>put()</code>还是<code>remove()</code>，这个属性都会<code>+1</code>，这是表示<strong>modCount属性代表的对HashMap的操作次数</strong>。至此，我们<code>remove()</code>方法已经分析得差不多了。那么可以来总结下<code>jdk1.8</code>中的<code>HashMap</code>了。</p><h3 id="JDK1-8中HashMap的总结"><a href="#JDK1-8中HashMap的总结" class="headerlink" title="JDK1.8中HashMap的总结"></a><span id="sum">JDK1.8中HashMap的总结</span></h3><p>在常量与属性中提及的内容不会在特性总结中重复提及！</p><ul><li>常量与属性  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="comment">// HashMap中Node&lt;K,V&gt;数组的默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// HashMap中Node&lt;K,V&gt;数组的极限容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap中扩容时的扩容因子 初始扩容阈值为 DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 16 * 0.75 = 12</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// HashMap中链表转红黑树的阈值，元素个数达到8（&gt;= 8）时链表会转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// HashMap中红黑树转链表的阈值，元素个数达到6（&lt;= 6）时红黑树又会转回链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// HashMap中数组长度到达此阈值才会发生链表转数组操作 否则会以扩容方法简化链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="comment">// 节点数组（Hash桶）</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// HashMap元素总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HashMap被操作次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 扩容阈值 计算方式是 数组长度 * 扩容因子（默认0.75）超过阈值的数组长度后会发生扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 扩容因子 默认值是常量 DEFAULT_LOAD_FACTOR = 0.75f </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li><li>特性总结<ul><li>HashMap数据结构为<strong>数组 + 链表 + 红黑树</strong>。</li><li>HashMap在第一次加入元素的时候初始化数组且每次加入元素会根据<code>threshold</code>是否需要扩容；加入链表结构时会使用“尾插法”。</li><li>HashMap允许存入<code>NULL</code>值的<code>key</code>，其对应的数组下标必为<code>0</code>。</li><li>HashMap在<code>hash()</code>过程中让高位也参与到计算中，为的是防止在计算元素下标时哈希碰撞。</li><li>HashMap不只是在达到阈值时发生扩容，也有可能在链表转红黑树时，因数组长度为达到<code>MIN_TREEIFY_CAPACITY = 64</code>而发生扩容。</li><li>HashMap扩容后，原下标的元素会根据其<code>hash</code>值对应扩容量二进制中<code>1</code>位值来判断其下标，对应此位的<code>hash</code>值为<code>0</code>则下标不变，为<code>1</code>则下标<code>+扩容量</code>。</li></ul></li></ul><h2 id="JDK1-7中的HashMap"><a href="#JDK1-7中的HashMap" class="headerlink" title="JDK1.7中的HashMap"></a>JDK1.7中的HashMap</h2><p>我们在阅读完<code>JDK1.8</code>中的<code>HashMap</code>后，再来阅读<code>JDK1.7</code>的<code>HashMap</code>话，那我们的侧重点就在于对两者了，也就是说不会像<code>JDK1.8</code>中那么精细的阅读。<strong>对于“JDK1.8中的HashMap”我在下文都会称前者，对于“JDK1.7中的HashMap”在下文中都会称后者。</strong></p><h3 id="new-HashMap-1"><a href="#new-HashMap-1" class="headerlink" title="new HashMap()"></a>new HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 与1.8中一致</span></span><br><span class="line">    threshold = initialCapacity; <span class="comment">// 1.8中保存的是 16 * 0.75的值 1.7直接保存数组长度 16</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次我把和构造函数相关的属性、常量及方法直接都列出来了。在<code>JDK1.7</code>的<code>HashMap</code>（下文用“后者”代替）中的构造方法中，初始化了两个属性<code>loadFactor</code>与<code>threshold</code>，而在<code>JDK1.8</code>的<code>HashMap</code>（下文用“前者”代替）中只初始化了<code>loadFactor</code>。关键不同在于，<code>threshold</code>扩容阈值。前者保存的是<code>16 * 0.75 = 12</code>，后者直接保存的数组长度<code>16</code>。我们接着<code>put()</code>往下看。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold); <span class="comment">// 此方法初始化table</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); <span class="comment">// 处理key=null</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length); <span class="comment">// 计算下标的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 循环此链表中的entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// 判断链表中是否存在此被put的元素 存在替换值并返回原值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); <span class="comment">// 链表中不存在调用addEntry()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize); <span class="comment">// 此方法保证 数组长度为 2^n</span></span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">// 修改了初始化的threshold = 16 变为与1.8中一致 threshold = 16 * 0.75 = 12</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity]; <span class="comment">// 初始化数组</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 当key=null时与jdk1.8中一致 放入数组下标为0的链表中</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">// 与1.8一致 获取下标即 hash值取模数组长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123; <span class="comment">// 判断当前是否需要扩容 当到达阈值时进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length); <span class="comment">// 扩容方法同1.8 2倍扩容</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>; <span class="comment">// 如果发生了扩容 hash值又得重新计算（rehash）</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length); <span class="comment">// hash值变了 自然下标也得重新计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">// 使用头插法</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入<code>put()</code>方法，首先发现<code>table</code>属性类型与前者不同，后者的类型是静态内部内<code>Entry&lt;K,V&gt;</code>的数组。从<code>Entry&lt;K,V&gt;</code>类可以看出，这也是一个单向链表的结构。所以，后者我们也暂时可以下定论，结构是<strong>数组 + 链表。</strong>继续阅读<code>put()</code>方法代码，如果当前<code>table</code>未被初始化时即<code>table == EMPTY_TABLE</code>，调用<code>inflateTable()</code>方法。进入此方法，上面发现与前者不同<code>threshold</code>又被修改了，这样就和前者阈值是同样的了。代码往下，判断了<code>key == null</code>时调用的处理方法<code>putForNullKey()</code>。同样进入此方法，发现此处也与前者相同，当<code>key == null</code>时，直接插入下标为<code>0</code>的链表。然后是经过<code>hash()</code>方法计算<code>key</code>的哈希值（<code>hash()</code>方法下面再做对比），再调用<code>indexFor()</code>计算此元素的下标。进入<code>indexFor()</code>方法，此处计算方式与前者也是相同的，使用了位计算<a href="#qumo">取模</a>获取下标。获取到下标后循环此下标下的<code>Entry&lt;K,V&gt;</code>链表，如果出现相同的<code>key</code>，替换<code>value</code>直接返回原有<code>value</code>。如果不存在，则会调用<code>addEntry()</code>方法。进入<code>addEntry()</code>方法，同样判断了<code>size &gt;= threshold</code>，不过此处与前者也有不同。前者会将新添加的元素插入后才进行扩容，而后者则先进行了扩容才将新添加的元素重新计算才插入链表，所以导致前者判断的是<code>&gt;</code>而无<code>=</code>判断，即前者必须超过阈值才会扩容，后者则是达到阈值即扩容（后者扩容方法之后分析），如果算上还没添加的新元素的话，那其实后者也必定大于阈值了。代码向下读，不论是否需要扩容，此时都会调用<code>createEntry()</code>方法来创建新<code>Entry&lt;K,V&gt;</code>节点插入此链表中。进入<code>createEntry()</code>方法，我们看到插入逻辑简单粗暴，让此下标直接引用了这个新创建的<code>Entry&lt;K,V&gt;</code>。进入<code>Entry&lt;K,V&gt;</code>的构造方法我们看到，被传入的当前链表的头节点被新建<code>Entry&lt;K,V&gt;</code>的<code>next</code>属性引用，显而易见的后者插入节点是使用的<strong>头插法</strong>。此点也与前者完全不同。在分析前者时，我们还分析了前者的<code>hash()</code>方法，那我们也来看看后者的<code>hash()</code>方法吧。</p><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash()"></a>hash()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> hashSeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，后者<code>hash()</code>方法比前者更加复杂。不过两者都是利用了位移运算来尽量让每位值都参与到<code>hash</code>算法中避免哈希碰撞。这里可以得出结论：两者的<code>hash()</code>算法不同。最后我们再来看看最重要的方法，<code>resize()</code>方法。</p><h3 id="resize-1"><a href="#resize-1" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key); <span class="comment">// 重新计算hash值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>resize()</code>方法无非就是将原来数组内的元素全部添加到新的数组中，但是前者不会去重新计算<code>hash</code>值（此处我们已经讲得很详细），而后者会通过<code>rehash</code>来重新计算。至此，我们有关<code>JDK1.7</code>源码中的<code>HashMap</code>也粗略的过了一遍了。最后，我们再来总结下这两者有什么不同。</p><h2 id="总结JDK1-8与JDK1-7的异同"><a href="#总结JDK1-8与JDK1-7的异同" class="headerlink" title="总结JDK1.8与JDK1.7的异同"></a><span id="sums">总结JDK1.8与JDK1.7的异同</span></h2><ol><li>在<code>JDK1.8</code>中，<code>HashMap</code>的数据结构为 <strong>数组 + 链表 + 红黑树</strong> 。而在<code>JDK1.7</code>中，数据结构仅为 <code>数组 + 链表</code>。这导致有关红黑树结构属性、常量、方法在<code>JDK1.7</code>中都不具备。</li><li>两者的节点类型不同。在<code>JDK1.8</code>中节点类型是<code>Node&lt;K,V&gt;</code>或<code>TreeNode&lt;K,V&gt;</code>，而在<code>JDK1.7</code>中为<code>Entry&lt;K,V&gt;</code>。</li><li>两者的<code>hash()</code>算法不同，且<code>JDK1.7</code>中会发生<code>rehash</code>重新计算哈希值。</li><li>两者在扩容<code>resize()</code>方法处理细节不同。<code>JDK1.8</code>中会先“插入”再扩容，而<code>JDK1.7</code>中则先扩容再<code>rehash</code>后插入。 </li><li>两者发生扩容的时机也有不同，<code>JDK1.8</code>中不只是在超过阈值时发生扩容，也有可能转红黑树时因数组没达到<code>64</code>的长度而发生扩容。</li><li>两者加入元素的方式不同，<code>JDK1.8</code>加入链表是“尾插法”，而<code>JDK1.7</code>则使用<code>头插法</code>。这直接导致<code>JDK1.7</code>在多线程情况下扩容时可能导致链表“成环”而死循环，<code>JDK1.8</code>修复了这点。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的&lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;JDK1.8&lt;/code&gt;之前的&lt;code&gt;HashMap&lt;/code&gt;来做比较。今天我将通阅读基于&lt;code&gt;JDK1.8&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;与&lt;code&gt;JDK1.7&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;的源码来与大家做一个分享。  &lt;/p&gt;
&lt;p&gt;我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。&lt;strong&gt;这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。&lt;/strong&gt;当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳&lt;code&gt;JDK1.8&lt;/code&gt;中的&lt;code&gt;HashMap&lt;/code&gt;&lt;a href=&quot;/2018/06/14/HashMap/#sum&quot;&gt;总结&lt;/a&gt;查看，或者JDK1.8与JDK1.7的&lt;a href=&quot;/2018/06/10/HashMap/#sums&quot;&gt;异同&lt;/a&gt;查看对比。  &lt;/p&gt;
&lt;p&gt;最后，我的&lt;a href=&quot;/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/&quot;&gt;源码阅读&lt;/a&gt;系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。&lt;br&gt;那么，废话就不说了，大家跟着我一起来阅读源码吧。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://www.hellozuofeng.cn/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码" scheme="https://www.hellozuofeng.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="https://www.hellozuofeng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从代码角度理解-JVM运行时数据区</title>
    <link href="https://www.hellozuofeng.cn/2018/06/10/runtimemedataarea/"/>
    <id>https://www.hellozuofeng.cn/2018/06/10/runtimemedataarea/</id>
    <published>2018-06-10T02:22:30.000Z</published>
    <updated>2021-03-01T10:39:14.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>一问到JVM运行时数据区，相信很多同学第一时间就能想到周志明老师《深入理解Java虚拟机》的内容。但是其中有一部分同学并没有真正的理解，只是单纯的将其“背诵”下来，但等一过了一阵又忘记了。今天我想根据一段代码运行过程带大家来真正理解JVM运行时数据区。还是按我的风格来，我不会上来就向大家介绍这些个数据区，而是让大家跟着代码一起，一步一步引出这些数据区。注意！此片文章并不深入讨论“类的加载”和“对象的创建”，但是可能会需要一点这方面的基础。此片文章推荐通读了周老师《深入理解Java虚拟机》的同学，但是没搞懂或者需要巩固的同学阅读。当然，和往常一样，我们最后还是会有一个<a href="/2018/06/10/runtimemedataarea/#conclusion">总结</a>。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>既然是跟着一段代码来理解并引出JVM各个运行时数据区，那我们先看看代码是如何设计的。  </p><p>第一个类是<code>Father</code>类。我们让其实现<code>Runable</code>接口，肯定是会使用多线程的。此处需要先声明：我们是理论基础上的理想情况，不考虑“并发”情况，只当“并行”执行。此类中除了重新<code>run()</code>方法外，还有两个实例方法<code>method1()</code>与<code>method2()</code>。下面是其代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result1 = method1();</span><br><span class="line">        <span class="keyword">int</span> result2 = method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">return</span> c + d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二类就<code>Son</code>类了。我们让其继承<code>Father</code>类，并重写<code>method2</code>方法。下面是其代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> e + f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个类就是我们的<code>Demo</code>类了。我们的<code>main()</code>方法在这个类中实现，并声明了基本类型常量<code>NUM1</code>与引用类型常量<code>Father</code>。当然还有实例基本类型属性<code>num2</code>与实例引用类型属性<code>son</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Father FATHER = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Son son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">        Thread sonThread = <span class="keyword">new</span> Thread(demo.son, <span class="string">&quot;Son-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread fatherThread = <span class="keyword">new</span> Thread(father, <span class="string">&quot;Father-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sonThread.start();</span><br><span class="line">        fatherThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>介绍完我们的代码，那么我将其跑起来吧。当我们执行<code>main()</code>方法时，<code>Demo</code>类就会由我们的类加载器加载到内存中了，此处我们引出了第一个内存区域“方法区”。</p><ul><li>方法区：方法区负责存储类型信息、常量、静态变量以及即时编译器编译后的代码缓存。其中我们的类型信息中的常量池中的信息（javap反编译后可看到）、常量以及静态变量都会加载到“方法区”中的“运行时常量池”中。在每一个运行中的JVM中，都只有一块叫“方法区”的内存区域，所以它是我们所有线程共享的区域。  </li></ul><p>继续读代码，我们发现我们的常量中有一个引用类型<code>Father</code>的常量<code>FATHER</code>，并且这个常量会直接创建一个<code>Father</code>类型实例，此时，我们引出了第二个内存区域“Java堆”。</p><ul><li>Java堆：我们创建的大部分对象实例会放在这个区域（不考虑栈上分配的情况）。和“方法区”一样，我们的每个运行中的JVM中都只有一快叫“Java堆”的内存区域，所以它也是我们所有线程所共享的。  </li></ul><p>而这个<code>Father</code>类型实例会被创建到我们的“Java堆”中，而常量<code>FATHER</code>会指向我们在“Java堆”中的<code>father</code>实例的内存地址。那么，我们现在来看看<code>main()</code>方法开始运行前，我们的“运行时数据区”是个什么样的结构（下图展示，“蓝色”表示线程共享）。  </p><p><img src="/2018/06/10/runtimemedataarea/1.png" alt="1"></p><p>当我们的<code>main()</code>方法开始<strong>在线程中运行</strong>时，此刻引出我们第三个内存区域“Java虚拟机栈”。  </p><ul><li>Java虚拟机栈：我们<strong>每个运行的线程</strong>会对应一个“Java虚拟机栈”，所以也有称其为“线程栈”。而每个方法在开始运行前，会创建一个栈帧进入这个<strong>先进后出（FILO）</strong>的栈中。既然是每个线程都会对应一个“Java虚拟机栈”，那么代表这块内存区域是线程私有的区域。  </li></ul><p>方法开始运行，那么它如何定位我们存放在“方法区”的方法代码呢？在我们的每个“栈帧中”保存了叫做“动态链接”的信息，这个信息指向的就是我们“运行时常量池”中该栈帧所属方法的引用。那如何知道我们代码运行到哪里了呢？此处我们引出了第四个内存区域“程序计数器”。  </p><ul><li>程序计数器：它可以看作当前线程所执行的字节码的行号指示器。因为每个线程都要记录一个字节码的行号，所以和栈一样，也是线程私有的。  </li></ul><p>当代码继续，我们此时创建了一个<code>Demo</code>类型的对象并赋值给了<code>demo</code>变量。因为<code>demo</code>实例中会有一个<code>Son</code>类型的实例<code>demo.son</code>属性，此时<code>Son</code>类型也会加载到我们的内存中。那么，<code>son</code>变量会储存在哪里呢？在我们的栈帧中，除了刚才说到的“动态链接”外，还有一块信息保存着这个方法内声明的本地变量，称其为“局部变量表”。当运行完<code>Demo demo = new Demo()</code>。我们来看看此时的内存区域情况（见下图，“黄色”表示线程独占）。</p><p><img src="/2018/06/10/runtimemedataarea/2.png" alt="2"></p><p>当代码运行至<code>fatherThread.start()</code>，已经是开启了另外两个线程了。可以看到，我们的重写的<code>run()</code>方法中调用了<code>method1()</code>由调用了<code>method2()</code>，在<code>fatherThread</code>中<code>method2()</code>会调用<code>father.method2()</code>，而在<code>sonThread</code>中<code>method2()</code>则会调用重写了的<code>son.method2()</code>。假设我们现在两个线程一起并行执行，并且都执行到了<code>method2()</code>的第一句代码。此时，我们的<code>method1()</code>方法应该已经出栈了，并且<code>method1()</code>方法也会引出我们“栈帧”的另外一块信息，“方法返回地址”。可以理解为，我们方法退出后返回到哪个方法的哪行代码。而且我们可以看到，<code>method1()</code>与<code>method2()</code>中都是简单的计算，这些计算都是经每个“栈帧”中的“操作数栈”来计算的。此刻我们的内存区域大概会是什么样的呢？此处我们忽略<code>main()</code>方法和<code>Demo</code>类与对象，只拿两个线程做比较（见下图）。</p><p><img src="/2018/06/10/runtimemedataarea/3.png" alt="3">  </p><p>至此，除了“本地方法栈”没有聊到，我们几个分区以及内存分区里面中存放的什么都了解了。而“本地方法栈”就是运行除<code>java</code>方法的栈，其他和我们“Java虚拟机栈”没太多区别，我们就一句带过了。现在我们来总结下内存运行时内存区域吧。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="conclusion">总结</span></h2><p>运行时数据区：</p><ul><li>线程共享：<ul><li>方法区：储存 类型信息 常量 静态变量 即使编译器编译后的代码缓存。<ul><li>运行时常量池：它是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li></ul></li><li>Java堆：Java堆在虚拟机启动时创建，被所有线程共享的最大区域，存放对象实例。<ul><li>新生代：<ul><li>eden：</li><li>survive0</li><li>survive1</li></ul></li><li>老年代：</li></ul></li></ul></li><li>线程私有<ul><li>Java虚拟机栈：<ul><li>栈帧：每个方法被执行都会同步创建一个栈帧。即栈中存储的就是栈帧<ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul></li></ul></li><li>本地方法栈：与虚拟机栈类似，只是它执行的是本地方法而非Java方法。</li><li>程序计数器：它可以看作当前线程所执行的字节码的行号指示器。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;一问到JVM运行时数据区，相信很多同学第一时间就能想到周志明老师《深入理解Java虚拟机》的内容。但是其中有一部分同学并没有真正的理解，只是单纯的将其“背诵”下来，但等一过了一阵又忘记了。今天我想根据一段代码运行过程带大家来真正理解JVM运行时数据区。还是按我的风格来，我不会上来就向大家介绍这些个数据区，而是让大家跟着代码一起，一步一步引出这些数据区。注意！此片文章并不深入讨论“类的加载”和“对象的创建”，但是可能会需要一点这方面的基础。此片文章推荐通读了周老师《深入理解Java虚拟机》的同学，但是没搞懂或者需要巩固的同学阅读。当然，和往常一样，我们最后还是会有一个&lt;a href=&quot;/2018/06/10/runtimemedataarea/#conclusion&quot;&gt;总结&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Java虚拟机" scheme="https://www.hellozuofeng.cn/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://www.hellozuofeng.cn/tags/JVM/"/>
    
  </entry>
  
</feed>
