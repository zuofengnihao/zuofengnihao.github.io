<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TAKO</title>
  
  
  <link href="https://www.hellozuofeng.cn/atom.xml" rel="self"/>
  
  <link href="https://www.hellozuofeng.cn/"/>
  <updated>2021-02-25T17:31:38.795Z</updated>
  <id>https://www.hellozuofeng.cn/</id>
  
  <author>
    <name>老板是只叫JOE的猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>源码解读——AbstractQuenedSynchronizer</title>
    <link href="https://www.hellozuofeng.cn/2018/06/15/aqs/"/>
    <id>https://www.hellozuofeng.cn/2018/06/15/aqs/</id>
    <published>2018-06-15T10:31:10.000Z</published>
    <updated>2021-02-25T17:31:38.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>内容</p><hr><h2 id="初看"><a href="#初看" class="headerlink" title="初看"></a>初看</h2><p>内容</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;内容&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初看&quot;&gt;&lt;a href=&quot;#初看&quot; class=&quot;headerlink&quot; title=&quot;初看&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="源码阅读" scheme="https://www.hellozuofeng.cn/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码" scheme="https://www.hellozuofeng.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="并发" scheme="https://www.hellozuofeng.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>源码解读——HashMap</title>
    <link href="https://www.hellozuofeng.cn/2018/06/10/HashMap/"/>
    <id>https://www.hellozuofeng.cn/2018/06/10/HashMap/</id>
    <published>2018-06-10T02:22:30.000Z</published>
    <updated>2021-02-25T17:29:39.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的<code>HashMap</code>和<code>JDK1.8</code>之前的<code>HashMap</code>来做比较。今天我将通阅读基于<code>JDK1.8</code>的<code>HashMap</code>与<code>JDK1.7</code>的<code>HashMap</code>的源码来与大家做一个分享。  </p><p>我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。<strong>这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。</strong>当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳<code>JDK1.8</code>中的<code>HashMap</code><a href="/2018/06/10/HashMap/#sum">总结</a>查看，或者JDK1.8与JDK1.7的<a href="/2018/06/10/HashMap/#sums">异同</a>查看对比。  </p><p>最后，我的<a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a>系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。<br>那么，废话就不说了，大家跟着我一起来阅读源码吧。</p><a id="more"></a><h2 id="JDK1-8中的HashMap"><a href="#JDK1-8中的HashMap" class="headerlink" title="JDK1.8中的HashMap"></a>JDK1.8中的HashMap</h2><p>每个人都又不同的阅读耐心。为了能让耐心不够的同学，可以在更有效的时间内记住更重要的内容，所有我们从优化更好的、使用率更高的1.8版本的HashMap开始阅读！  </p><p>那么我们来<code>new HashMap()</code>，跟着无参构造函数进入源码。</p><h3 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a>new HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在<span id="con">无参构造函数</span>中，源码只是设置了属性<code>loadFactor</code>的值为一个<code>DEFAULT_LOAD_FACTOR</code>的常量。此时我们碰到了第一个属性和第一个常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 第一个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 第一个常量 </span></span><br></pre></td></tr></table></figure><p>可以看出这<code>DEFAULT_LOAD_FACTOR</code>常量是<code>loadFactor</code>属性的默认值（<code>0.75</code>），但暂时没有其他信息，让我们记住这个属性和常量的值。既然源码只是初始化了一下一个属性，那么我进入<code>put()</code>方法。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>put()</code>方法中，我们看到<code>key</code>被传入了<code>hash()</code>方法。显然这是一个获取<code>key</code>hash值的算法。那么我们来看1.8中是如何计算key的hash值的。  </p><h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a><span id="hash">hash()</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// key==null时返回hash值0，否则调用hashCode()获取hash值并异或此hash高位并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>HashMap</code>中的静态的不可重写的方法，返回一个<code>int</code>类型的hash值。当传入的<code>key</code>是<code>null</code>时，直接返回了值<code>0</code>。由此我们可以得到源码阅读的第一条结论，<strong>HashMap在jdk1.8中可以存放key为null的键值对，且key为null时的hash值即<code>0</code>。</strong><br>继续向下看，源码中，<code>key</code>调用了<code>Object</code>的<code>hashCode()</code>方法获取到了一个Hash值，再和此hash值的<a href="#high">高位</a>进行了一个异或<code>^</code>运算。这样做的目的是什么呢？为什么不直接返回<code>Object</code>中<code>hashCode()</code>的值呢？这里我们暂时记住它，我们回到<code>put()</code>方法继续往下看，源码中调用了<code>putVal()</code>方法。</p><blockquote><p><span id="high"><code>&gt;&gt;&gt; 16</code></span>表示无符号右位移16位运算，<code>int</code>类型有32位的长度，右位移16位即截取了此<code>int</code>值的左边16位的值，而所谓“左边16位”是口语化的说法，身为程序员，应该知道，平时我们称此为“高位”，而对应的“右边16位”我们称“低位”，如果要截取低位的值，可以使用<code>&amp; 0x0000FFFF</code>的运算获得。这样的“位运算”是基础知识，此篇文章就不再详细介绍了，如果不懂可以自行google或baidu。  </p></blockquote><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//判断table是否被初始化</span></span><br><span class="line">        <span class="comment">// table未被初始化时</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// resize()方法中初始化Node数组</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// hash值与数组长度模获取下标，再获获取tab对应此下标的Node</span></span><br><span class="line">            <span class="comment">// 当此下标下的Node为null，已进加入元素（key,value）创建Node并赋值到此下标</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当此下标的Node不为空时</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断获取到的Node中的元素与新加入的元素（key,value）是否为同一元素</span></span><br><span class="line">                e = p; <span class="comment">// 当此Node中元素与新加入元素为同一元素时，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断获取到的Node是都为 红黑树结构</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">// 如果获取的Node是红黑树结构时，将新加入的元素创建TreeNode并添加至红黑树，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 当此Node为链表结构且Node中元素与新加入的元素不为同一元素时</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 循环此Node链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//判断链表是否含有后继节点（next是否为null）其用意是判断该节点是否已经是尾部节点</span></span><br><span class="line">                        <span class="comment">// 当next=null时，无后继节点时，即当前节点已经是尾节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 将新加入的元素创建新Node赋值给当前Node（尾节点）的next，即让新加入的元素成为尾节点（尾插法）。</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st 判断链表的长度是否超过阈值（默认值8）</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">// 当链表的长度超过阈值8 则将整个链表转成红黑树结构</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断获取到的Node中的next元素与新加入的元素（key,value）是否为同一元素</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key 如果是加入元素是新构造的节点时 即此链表或红黑树中没有与新加入元素相同元素</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount; <span class="comment">// 每次putVal 此值必定+1 表示HashMap被修改从次数</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 判断当前HashMap的容量size 是否大于阈值threshold </span></span><br><span class="line">            resize(); <span class="comment">// 当容量过大时发生扩容</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>putVal()</code>方法，代码读到<code>if ((tab = table) == null || (n = tab.length) == 0)</code>（行号4），第二个属性<code>table</code>出现，此属性的类型是一个静态内部类<code>Node&lt;K,V&gt;</code>的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 第二个属性table 链表数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类，链表的节点类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 省略set、get等方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很显然，这个静态内部类是一个链表的节点类型，并且此链表是一个单向链表（只有next，无prev）。那此行代码的用意就在于判断<code>table</code>是否已经被初始化了（<a href="#transient">transient关键字的意义</a>）。记得吗？我们在<a href="#con">构造函数</a>中，只初始化了一个参数<code>loadFactor = DEFAULT_LOAD_FACTOR = 0.75f</code>，那么代码到<code>n = (tab = resize()).length</code>（行号6）。<code>resize()</code>方法应该会初始化节点数组<code>node&lt;K,V&gt;[] table</code>（从代码逻辑可以看出，不初始化下面的逻辑将无法继续）。而这个<code>table</code>就是一个链表数组，那么，我们可以暂时得到结论：<strong>HashMap是数组加链表的数据结构，并且这个数组是在第一次put()时才被初始化</strong>。我们先把<code>resize()</code>方法放一放，继续向下读。  </p><blockquote><p>被<span id="transient"><code>transient</code></span>关键字修饰的属性不会别序列化。</p></blockquote><p>代码来到<code>if ((p = tab[i = (n - 1) &amp; hash]) == null)</code>（行号7），这里是使用元素的<code>hash</code>值来计算数组下标。按照我们平时的逻辑，我们一般会用<code>hash</code>值去与数组长度<code>n</code>取模来获取定位此元素在数组中的位置，这样也利用了<code>hash</code>值且不会发生<code>ArrayIndexOutOfBoundsException</code>（数组下标越界）。而源码中是<code>(n - 1) &amp; hash</code>方式来定位下标。其实，源码是使用了效率更高的位运算方法来<a href="#qumo">取模</a>的。现在我们知道了如何定位数组下标的，回到<a href="#hash">之前</a><code>hash()</code>方法。为什么要用高位去与上低位呢？目的是为了减少哈希碰撞（降低下标值相等的概率）。试想一下，如果我们获取到是<code>hash</code>值都是<code>1101 0000</code>、<code>1000 0000</code>、<code>1010 0000</code>等这种低位值都“相似”的值，而这些值去与上同一个值（数组长度）且这个值也不大（比如<code>0000 1010</code>），势必我们得到的结果就会一样了，即发生了哈希碰撞。为了减少哈希碰撞，那么，我们就得想办法，让高位也参与到运算中。<strong>因此，源码中使用让低位与上高位这样的操作，目的是让高位参与到取模运算中来，以避免哈希碰撞</strong>。  </p><blockquote><p><span id="qumo">取模</span>小技巧 <code>val % 2^n = val &amp; (2^n - 1)</code>。在<code>HashMap</code>中，数组的长度是必定是2^n。</p></blockquote><p>我们继续往下读，<code>tab[i] = newNode(hash, key, value, null)</code>（行号9）。这行代码就是当此下标元素为空时，直接将我们这个新put进来的元素构造成<code>Node&lt;K,V&gt;</code>赋值给了此下标（情况如下图）。<br><img src="/2018/06/10/HashMap/1.png" alt="1"><br>那么，当我们此下表下已经存在链表了，会是什么情况呢？<span id="1314"><code>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code>（行号13和14）</span>，如果存在链表了，会先判断我们新加入的元素和此链表的第一个<code>Node&lt;K,V&gt;</code>节点是否为同一元素，即判断它们的Hash值和key是否一致。如果新加入的元素是同一元素，那么很好办，将新值value替代老值即可。  </p><p>代码继续向下<code>else if (p instanceof TreeNode)</code>（行号16），如果不为同一元素的话，会去判断是否为<code>TreeNode&lt;K,V&gt;</code>类型。又出现了一个新的静态内部类<code>TreeNode&lt;K,V&gt;</code>，我们来看看这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">// 省略构造、get、set等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>left right red</code>这三个属性，我们基本能看出这个类型就是一个红黑树的节点类型了。那么，我们需要修改下之前的结论：<strong>HashMap是数组加链表再加红黑树的数据结构</strong>。如果是<code>TreeNode&lt;K,V&gt;</code>，则<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>（行号17），<code>putTreeVal()</code>方法中无非也是判断是否存在相同元素，存在相同元素就替代值，不存在就插入到这个红黑树（如下图所示）。至于，这个链表是何时转变成红黑树的呢？我们带着这个疑问继续往下读。<br><img src="/2018/06/10/HashMap/2.png" alt="2">  </p><p>如果这时的结构是链表呢？那我们就应该循环这个获取这个链表里的每个<code>Node&lt;K,V&gt;</code>来与新加入的元素进行比较，如果链表中一旦有与新加入元素相同的元素，就和<a href="#1314">之前代码</a>（行号13和14）一样的逻辑，替代其值就行了。源码也显示，我们的想法是没有错的。<code>for (int binCount = 0; ; ++binCount)</code>（行号19）开始循环这个链表，但源码中是获取的当前节点的后继节点<code>if ((e = p.next) == null)</code>（行号20）,因为在之前的逻辑中，我们已经对头节点进行了处理了。这样一来这句代码的用意就是先判断了当前节点是否是尾节点，如果当前节点是尾节点了，就直接将新加入的节点加入到尾节点后面即可，<code>p.next = newNode(hash, key, value, null)</code>（行号22）。那么我们现在又可以得到一个结论：<strong>HashMap中加入新的链节点，是采用的尾插法</strong>。（如下图所示）<br><img src="/2018/06/10/HashMap/3.png" alt="3">    </p><p>代码来到<code>if (binCount &gt;= TREEIFY_THRESHOLD - 1)</code>（行号23），这是里出现了我们第二个常量<code>TREEIFY_THRESHOLD = 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>如果<code>Node&lt;K,V&gt;</code>数量大于等于这个值<code>-1</code>时（为什么需要<code>-1</code>呢？因为，我们是获取的next，是从第二个节点开始计算的），会调用<code>treeifyBin(tab, hash)</code>（行号24）方法。从方法的名字上我们就可以判断，这是一个将链表变形成红黑树的方法。也就是说，当链表的长度超过<code>TREEIFY_THRESHOLD = 8</code>时，链表就会生成红黑树了。这里我们又可以出一个结论：<strong>TREEIFY_THRESHOLD常量是链表转红黑树的阈值，当链表长度超过8时，链表将会变形成红黑树结构</strong>。  </p><p>代码继续往下读，接下来的就是与行号13、14相同的逻辑了（行号27和28）。之后，我们判断了下是否为非新加入元素，而只是替换值，如果是替换值返回被替换的值（行号33到38）。然后代码来到<code>++modCount</code>（行号41），出现了一个新的值属性<code>modCount</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>就目前的信息，我们只知道如果调用了<code>putVal()</code>方法，此值必定加1，再无其他信息，等获取到更多信息我们再来定义这个值的意义。然后又出现了两个新的属性<code>size</code>与<code>threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>其中<code>size</code>很好理解，这就是当前<code>HashMap</code>的大小。至于<code>threshold</code>属性，代码<code>if (++size &gt; threshold)</code>（行号42）中的意思是，如果当前<code>HashMap</code>大小超过了这个值的时候，就会调用<code>resize()</code>方法。之前我们没有进入这个方法查看过，知道它一定会初始化<code>table</code>属性，这里又一次调用了这个方法，会不会这个方法就是修改<code>table</code>的方法呢？换句话说，这个方法就是修改数组的方法。我们接下来，进入<code>resize()</code>一探究竟。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; </span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 获取当前数组长度 数组未初始化时长度为0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// 获取当前数组长度阈值 threshold int属性初始化值也为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">// 声明新数组长度与阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断当前数组长度是否&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 此处判断当前数组大小是否超过MAXIMUM_CAPACITY（极限长度）</span></span><br><span class="line">            threshold = Integer.MAX_VALUE; <span class="comment">// 令数组阈值等于极限阈值长度 即Integer最大长度</span></span><br><span class="line">            <span class="keyword">return</span> oldTab; <span class="comment">// 返回当前数组 即不再进行扩容操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 当前数组的长度&lt;&lt;1(左位移1位) 即乘2操作 令新数组两倍扩容 并判断是否小于MAXIMUM_CAPACITY（极限长度）</span></span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 判断数组当前的长度是否&gt;=数组初始化长度(DEFAULT_INITIAL_CAPACITY = 16) </span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 新数组的阈值同样乘以2 即新数组阈值也成倍扩大</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">// 当前数组长度=0 但数组阈值&gt;0 此情况是调用的带参构造时 会令threshold=初始化长度 但数组并未初始化 则让新数组长度=threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults 当前数组长度=0且当前数组阈值=0 即数组未被初始化时</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 初始化数组的大小等于 DEFAULT_INITIAL_CAPACITY = 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 初始化数组的阈值 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY = 0.75 * 16 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 此处同为带参构造时的逻辑延续 上面只令newCap = oldThr 并未初始化newThr的值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor; <span class="comment">// 令新数组阈值 = 新数组长度 * 扩容因子0.75（loadFactor = DEFAULT_LOAD_FACTOR）</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 令当前阈值=新数组的阈值（即将扩容的数组）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 初始化新数组</span></span><br><span class="line">    table = newTab; <span class="comment">// 令当前数组=新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 判断当前数组是否为null 当前数组只有未被初始化时才会=null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 循环数组</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断此下标j下的元素是否=null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 判断此下标下的元素是否存在后继元素 即判断是否只有一个头节点元素</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 重新根据hash值计算对应新数组中的位置</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断节点是否为红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">// 分裂红黑树</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order 分裂链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看这个方法是如何初始化<code>table</code>的。先将和初始化<code>table</code>无关的代码省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>table=null</code>，可以得出<code>oldCap = 0</code>。又因<code>int</code>类型属性默认值为<code>0</code>可以得出<code>oldThr = 0</code>。所以代码不会进入<code>oldCap &gt; 0</code>，也不会进入<code>oldThr &gt; 0</code>，只会进入<code>else</code>的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新的常量<code>DEFAULT_INITIAL_CAPACITY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>而代码逻辑是令<code>newCap</code>等于了这个常量<code>16</code>，令<code>newThr</code>等于了我们之前在构造方法里使用过的常量<code>DEFAULT_INITIAL_CAPACITY = 0.75f</code>乘以了这个常量，结果为<code>0.75 * 16 = 12</code>。代码继续向下来到<code>threshold = newThr</code>，即令<code>threshold</code>属性等于刚才计算的值<code>12</code>。还记得吗？我们进入<code>resize()</code>方法，除了初始化功能外，还会有一个判断，就是和这个属性有关联的<code>++size &gt; threshold</code>，当整个<code>HashMap</code>的元素总量大于这个值时，也会进入。我们先把初始化代码读完，之后再来看看这个情况下进入<code>resize()</code>方法都干了些什么。代码继续到<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>，很显然，这里初始化了<code>table</code>数组了，并以<code>newCap</code>为数组长度，那么我们是不是可以得到一个结论：<strong>DEFAULT_INITIAL_CAPACITY常量是HashMap中Node数组的默认初始化长度</strong>。最后返回了初始化的这个数组，至此初始化逻辑过了一遍。  </p><p>接下来，我们看看<code>resize()</code>方法的全貌，当已经初始化了<code>table</code>并且<code>++size &gt; threshold</code>时，逻辑是怎么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        ... <span class="comment">//省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随代码进入<code>if (oldCap &gt; 0) &#123;&#125;</code>中的逻辑。先是判断了<code>if (oldCap &gt;= MAXIMUM_CAPACITY)</code>，这里又出现一个常量，从名字就能推断，<strong>MAXIMUM_CAPACITY是数组长度的极限长度</strong>，是一种极端情况的处理。下面的逻辑是让<code>threshold = Integer.MAX_VALUE</code>并直接返回了<code>table</code>，老规矩先记住这里之后再来总结。代码向下<code>else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</code>，这里让<code>newCap</code>即将新建的数组的长度等于了当前数组的长度乘以二（<code>&lt;&lt; 1</code>即乘2操作）。又执行<code>newThr = oldThr &lt;&lt; 1;</code>令<code>newThr</code>的值也等于了<code>oldThr</code>乘以2。之后，同样是<code>threshold = newThr;</code>，并创建数组<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>。这不就是创建了一个容量为原数组两倍的新数组吗？哦，原来<code>resize()</code>方法是一个数组的扩容方法，当<code>++size &gt; threshold</code>时进行扩容，那<code>threshold</code>属性就“扩容”触发的“阈值”了，接下来<code>if (oldTab != null)</code>里面的逻辑，就上让原来的数组元素转移到新的数组中的逻辑。我们此时，是不是可以得到这样的结论：<strong>threshold属性是触发扩容的“阈值”属性，它的初始化默认值为 DEFAULT_INITIAL_CAPACITY(0.75) x DEFAULT_INITIAL_CAPACITY(16)即12。而DEFAULT_INITIAL_CAPACITY常量则是扩容“阈值”的因子。而扩容的方式就是将数组长度成倍增长。</strong>  之后的代码逻辑，无非就是将原先的数组里面的元素转移到新数组中，最后返回这个新数组。  </p><p>至此，我们将<code>resize()</code>方法也过了一遍了，它就是我们<code>HashMap</code>中数组的扩容方法。这里，我们有必要把数组扩容后每个元素的对应的数组下标再来进行下分析。我们现在知道了扩容过程就是将数组容量翻倍，那原来对应某个下标的元素也将以<code>hash &amp; n - 1</code>方式取模重新计算下标。试想一下，如果原数组大小为<code>16</code>，<code>hash</code>值为<code>4</code>与<code>hash</code>值为<code>20</code>的元素必定会在同以数组下标<code>4</code>的链表上；当扩容到<code>32</code>时，<code>hash</code>值为<code>4</code>的元素计算的下标仍然为<code>4</code>，而<code>hash</code>值为<code>20</code>的元素的下标变成了<code>20</code>。发现了吗？<code>20</code>正好比<code>4</code>大一个扩容量<code>16</code>。其实发生扩容后，如果不在原下标下了，那么此元素的下标正好变为了<code>原下标 + 扩容量</code>。如果我们动态化的看，扩容就像是在创建一个一样长度的数组，将同一下标下的元素分成两份，一遍放一份，然后将数组拼接起来。或者可以理解为将其中一份往右移动<code>扩容量</code>的长度（如下图所示）。<br><img src="/2018/06/10/HashMap/4.png" alt="4"><br>但是，我们发现源码中似乎和我们设想的有所不同。它并没有用<code>hash &amp; newCap - 1</code>，这样的逻辑来分裂链表，我们看到的逻辑是<code>if ((e.hash &amp; oldCap) == 0)</code>的判断，为<code>0</code>则不下标不动，反之下标为<code>j + oldCap</code>。这样做的意义和<code>hash &amp; newCap - 1</code>的结果不会有出入？为什么？我们验证一下。首先有个前提，我们已知<code>HashMap</code>中的数组长度永远是<code>2^n</code>并且一次扩容是扩大一倍，可以理解为左位移一位即<code>&lt;&lt; 1</code>。我们用上图中的数据来做个比较，<code>4 - 1 = 3</code>转二进制为<code>11</code>，<code>8 - 1 = 7</code>转二进制为<code>111</code>，这两个值不同之处在于，<code>7</code>比<code>3</code>多出一个高位值。而恰恰所有<code>2^n - 1</code>的值都是一串<code>1</code>，比如<code>16 - 1 = 15 = 1111</code>，<code>32 - 1 = 31 = 11111</code>，那么每次扩容重新计算下标时，我们<code>hash</code>永远不变，<code>newCap</code>又永远是在<code>oldCap</code>的基础上高位多一个<code>1</code>。而对应的下标“动”或“不动”，只要看<code>hash</code>值中对应多出的这个高位值<code>1</code>是否为<code>0</code>即可，为<code>0</code>下标不变，反之下标<code>+n</code>。理解了这里，就很好理解为什么用<code>&amp; oldCap == 0</code>来判断了，因为<code>oldCap</code>恰恰就是对应这个高位值。还是拿上面的数据举例，<code>oldCap = 4</code>转二进制<code>0100</code>，是不是<code>0011</code>与<code>0111</code>多出的这个高位？所有，我们用<code>if ((e.hash &amp; oldCap) == 0)</code>的判断就能推倒出这个元素该不该“移动”了。下面的表格是拿上面的数据填充的，可以加深大家的理解。</p><p>| 数值 | 二进制 | 7(newCap=8)对比3(oldCap=4)多出的高位值 | &amp;3的结果 | &amp;7的结果 | 对应的高位值 | “动”否<br>| :-: | :-: | :-: | :-: | :-: | :-: |<br>| 47 | 0010 1111 | 0100 = 4(oldCap) | 0010 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0010 1111 &amp; 0000 0111 = 000 0111 = 7 | 101[1]11 | Yes |<br>| 15 | 0000 1111 | 0100 = 4(oldCap) | 0000 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0000 1111 &amp; 0000 0111 = 0000 0111 = 7 | 0000 1[1]11 | Yes |<br>| 3 | 0000 0011 | 0100 = 4(oldCap) | 0000 0011 &amp; 0000 0011 = 0000 0011 = 3 | 0000 0011 &amp; 0000 0111 = 0000 0011 = 3 | 0000 0[0]11 | No |<br>| 99 | 0110 0011 | 0100 = 4(oldCap)  | 0110 0011 &amp; 0000 0011 = 0000 0011 = 3 | 0110 0011 &amp; 0000 0111 = 0000 0011 = 3 | 0110 0[0]11 | No |<br>| 31 | 0001 1111 | 0100 = 4(oldCap) | 0001 1111 &amp; 0000 0011 = 0000 0011 = 3 | 0001 1111 &amp; 0000 0111 = 0000 0111 = 7 | 0001 1[1]11 | Yes |</p><p>到这里我们还只是讲了链表结构的在扩容后的变化，红黑树结构在扩容后的变化应该与链表时差不多的。我们已经知道链表在超过<code>TREEIFY_THRESHOLD = 8</code>时，会转化为红黑树，那红黑树扩容后，也会分为两部分，那就表示红黑树会被分成两颗树，是这样的吗？那就需要我们进入<code>split()</code>方法中一探究竟了。</p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码前面声明<code>TreeNode&lt;K,V&gt;</code>（行号4，5）来看，我们很容易就得到了结论，确实是将这个树一分为二了。和链表的扩容之后分配元素的逻辑也是是相同的<code>if ((e.hash &amp; bit) == 0)</code>（行号10），只要证明<code>bit</code>的值是否为<code>oldCap</code>即可。代码回到<code>resize()</code>的38行，<code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code>，没错，传入的就是<code>oldCap</code>的值。代码往下看，分裂成两个树结构后，分别对“两棵树”做了判断，代码行号28-29和37-38。此处又出现了一个新的常量<code>UNTREEIFY_THRESHOLD</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>如果长度<code>&lt;= UNTREEIFY_THRESHOLD = 6</code>这个值，将会调用<code>untreeify()</code>方法。从方法名和返回值就可以看出，这就是树结构转链表的方法，那么我们就能推导出结论：<strong>UNTREEIFY_THRESHOLD常量是红黑树最小元素阈值，当红黑树元素小于等于6时红黑树又会转链表。</strong> 那如果长度<code>&gt; UNTREEIFY_THRESHOLD = 6</code>，调用<code>treeify()</code>方法。这个方法是真正转红黑树的方法，看下面的代码逻辑也可以看出，这些处理只是将<code>TreeNode&lt;K,V&gt;</code>串起来而已。如果是这样，那么我前面没进入阅读的方法<code>treeifyBin()</code>又是什么方法呢？我们大概猜得到，应该是将<code>Node&lt;K,V&gt;</code>转成<code>TreeNode&lt;K,V&gt;</code>的方法，并且也只是将<code>TreeNode&lt;K,V&gt;</code>串了起来，然后方法内部再调用<code>treeify()</code>方法将串好的<code>TreeNode&lt;K,V&gt;</code>真正转为红黑树。那么进入<code>treeifyBin()</code>方法验证下我们的想法。</p><h3 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a>treeifyBin()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// 数组长度小于MIN_TREEIFY_CAPACITY 64时，不会转红黑树，只是扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入方法，我们就看到了最后一个常量<code>MIN_TREEIFY_CAPACITY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>代码<code>if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</code>（行号3）是将数组的长度与此常量进行了对比判断，即当数组的长度不满足<code>64</code>时不会进行链表转红黑树，而且尽量使数组扩容来解决链表长度过长的问题。之后的逻辑就非常清晰了，就是我们说的，调用<code>treeify()</code>方法转成红黑树结构。只是<code>64</code>长度的数组，看上去好像挺大的，其实我只进行两次扩容就达到了这个值了。默认长度是<code>16</code>，扩容一次翻倍变<code>32</code>，再一次就是<code>64</code>了。  </p><p>至此，我们已经将<code>put()</code>方法涉及到的绝大部分内容，包括方法、常量、属性等等都过了一遍了，<code>HashMap</code>重点知识基本上都点到了，以防有遗漏，我们还是看看<code>remove()</code>方法吧。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>put()</code>方法类似，先根据<code>key</code>计算了<code>hash</code>，再调用了<code>final</code>修饰的<code>removeNode()</code>方法。<code>hash()</code>方法我们之前分析过了，直接进入<code>removeNode()</code>看看吧。</p><h3 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; <span class="comment">// 判断当前数组不为null</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断需要移除的元素的key对应的数组的下标链表或红黑树元素不为null</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; </span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断此下标下的链表或红黑树的首节点是否是需要移除的元素</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果首节点不是需要移除的元素</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断此下标下的元素集合类型是否是红黑树</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); <span class="comment">// 获取红黑树中对应的此key的节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 如果是链表类型 循环链表 获取链表中对应的此key的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 记录下一个节点的前置prev节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || <span class="comment">// 判断是否找到此key对应的节点</span></span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断此节点的类型是否为红黑树</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable); <span class="comment">// 为红黑树时调用红黑树的移除方法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 判断此节点是否为链表首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 如果是链表首节点直接将此节点next节点赋予此下标</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;<span class="comment">// 非链表首节点则p为此节点前置节点 将前置节点的next指向此节点的next</span></span><br><span class="line">            ++modCount; <span class="comment">// 操作次数+1</span></span><br><span class="line">            --size; <span class="comment">// HashMap的大小-1</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中先是判断了此时<code>HashMap</code>中的数组<code>table</code>是否为空<code>(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0</code>（行号4），再判断了需要移除的这个<code>key</code>计算出来的下标下的元素是否为空<code>(p = tab[index = (n - 1) &amp; hash]) != null</code>（行号5）。如果有一者为空，表示此<code>key</code>无映射的元素，直接返回空。如果这两者都不为空，那么我们就需要在这个链表或者说是红黑树中找到这个key映射的元素。代码行号<code>12</code>是在红黑树结构中找到此元素，代码行号<code>14-23</code>是在链表结构中找到此元素。之后再判断是否找到了此元素（行号25、26）。如果没找到，则还是返回空。找到了此元素的话，再判断这个元素类型是链表还是红黑树。是红黑树则调用<code>removeTreeNode()</code>（行号28）移除此元素。是链表的话，则判断是否为头节点。如果是链表头节点则直接将此节点的后继节点<code>next</code>放到此下标下即可<code>tab[index] = node.next;</code>（行号30），但如果不是头节点，就会将记录的此节点的前置节点的<code>next</code>指向此节点的<code>next</code>来完成删除<code>p.next = node.next;</code>（行号32）。  </p><p>之后，我们又看到<code>modCount</code>属性和<code>size</code>属性，分别做了<code>+1</code>处理和<code>-1</code>处理。移除元素<code>size-1</code>很好理解，那<code>modCount</code>表示什么呢？不论是<code>put()</code>还是<code>remove()</code>，这个属性都会<code>+1</code>，这是表示<strong>modCount属性代表的对HashMap的操作次数</strong>。至此，我们<code>remove()</code>方法已经分析得差不多了。那么可以来总结下<code>jdk1.8</code>中的<code>HashMap</code>了。</p><h3 id="JDK1-8中HashMap的总结"><a href="#JDK1-8中HashMap的总结" class="headerlink" title="JDK1.8中HashMap的总结"></a><span id="sum">JDK1.8中HashMap的总结</span></h3><p>在常量与属性中提及的内容不会在特性总结中重复提及！</p><ul><li>常量与属性  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="comment">// HashMap中Node&lt;K,V&gt;数组的默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// HashMap中Node&lt;K,V&gt;数组的极限容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap中扩容时的扩容因子 初始扩容阈值为 DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 16 * 0.75 = 12</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// HashMap中链表转红黑树的阈值，元素个数达到8（&gt;= 8）时链表会转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// HashMap中红黑树转链表的阈值，元素个数达到6（&lt;= 6）时红黑树又会转回链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// HashMap中数组长度到达此阈值才会发生链表转数组操作 否则会以扩容方法简化链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="comment">// 节点数组（Hash桶）</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// HashMap元素总数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HashMap被操作次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 扩容阈值 计算方式是 数组长度 * 扩容因子（默认0.75）超过阈值的数组长度后会发生扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 扩容因子 默认值是常量 DEFAULT_LOAD_FACTOR = 0.75f </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li><li>特性总结<ul><li>HashMap数据结构为<strong>数组 + 链表 + 红黑树</strong>。</li><li>HashMap在第一次加入元素的时候初始化数组且每次加入元素会根据<code>threshold</code>是否需要扩容；加入链表结构时会使用“尾插法”。</li><li>HashMap允许存入<code>NULL</code>值的<code>key</code>，其对应的数组下标必为<code>0</code>。</li><li>HashMap在<code>hash()</code>过程中让高位也参与到计算中，为的是防止在计算元素下标时哈希碰撞。</li><li>HashMap扩容后，原下标的元素会根据其<code>hash</code>值对应扩容量二进制中<code>1</code>位值来判断其下标，对应此位的<code>hash</code>值为<code>0</code>则下标不变，为<code>1</code>则下标<code>+扩容量</code>。</li></ul></li></ul><h2 id="JDK1-7中的HashMap"><a href="#JDK1-7中的HashMap" class="headerlink" title="JDK1.7中的HashMap"></a>JDK1.7中的HashMap</h2><p>我们在阅读完<code>JDK1.8</code>中的<code>HashMap</code>后，再来阅读<code>JDK1.7</code>的<code>HashMap</code>话，那我们的侧重点就在于对两者了，也就是说不会像<code>JDK1.8</code>中那么精细的阅读。<strong>对于“JDK1.8中的HashMap”我在下文都会称前者，对于“JDK1.7中的HashMap”在下文中都会称后者。</strong></p><h3 id="new-HashMap-1"><a href="#new-HashMap-1" class="headerlink" title="new HashMap()"></a>new HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 与1.8中一致</span></span><br><span class="line">    threshold = initialCapacity; <span class="comment">// 1.8中保存的是 16 * 0.75的值 1.7直接保存数组长度 16</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次我把和构造函数相关的属性、常量及方法直接都列出来了。在<code>JDK1.7</code>的<code>HashMap</code>（下文用“后者”代替）中的构造方法中，初始化了两个属性<code>loadFactor</code>与<code>threshold</code>，而在<code>JDK1.8</code>的<code>HashMap</code>（下文用“前者”代替）中只初始化了<code>loadFactor</code>。关键不同在于，<code>threshold</code>扩容阈值。前者保存的是<code>16 * 0.75 = 12</code>，后者直接保存的数组长度<code>16</code>。我们接着<code>put()</code>往下看。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold); <span class="comment">// 此方法初始化table</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); <span class="comment">// 处理key=null</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length); <span class="comment">// 计算下标的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 循环此链表中的entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// 判断链表中是否存在此被put的元素 存在替换值并返回原值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); <span class="comment">// 链表中不存在调用addEntry()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize); <span class="comment">// 此方法保证 数组长度为 2^n</span></span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">// 修改了初始化的threshold = 16 变为与1.8中一致 threshold = 16 * 0.75 = 12</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity]; <span class="comment">// 初始化数组</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 当key=null时与jdk1.8中一致 放入数组下标为0的链表中</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">// 与1.8一致 获取下标即 hash值取模数组长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123; <span class="comment">// 判断当前是否需要扩容 当到达阈值时进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length); <span class="comment">// 扩容方法同1.8 2倍扩容</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>; <span class="comment">// 如果发生了扩容 hash值又得重新计算（rehash）</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length); <span class="comment">// hash值变了 自然下标也得重新计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">// 使用头插法</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入<code>put()</code>方法，首先发现<code>table</code>属性类型与前者不同，后者的类型是静态内部内<code>Entry&lt;K,V&gt;</code>的数组。从<code>Entry&lt;K,V&gt;</code>类可以看出，这也是一个单向链表的结构。所以，后者我们也暂时可以下定论，结构是<strong>数组 + 链表。</strong>继续阅读<code>put()</code>方法代码，如果当前<code>table</code>未被初始化时即<code>table == EMPTY_TABLE</code>，调用<code>inflateTable()</code>方法。进入此方法，上面发现与前者不同<code>threshold</code>又被修改了，这样就和前者阈值是同样的了。代码往下，判断了<code>key == null</code>时调用的处理方法<code>putForNullKey()</code>。同样进入此方法，发现此处也与前者相同，当<code>key == null</code>时，直接插入下标为<code>0</code>的链表。然后是经过<code>hash()</code>方法计算<code>key</code>的哈希值（<code>hash()</code>方法下面再做对比），再调用<code>indexFor()</code>计算此元素的下标。进入<code>indexFor()</code>方法，此处计算方式与前者也是相同的，使用了位计算<a href="#qumo">取模</a>获取下标。获取到下标后循环此下标下的<code>Entry&lt;K,V&gt;</code>链表，如果出现相同的<code>key</code>，替换<code>value</code>直接返回原有<code>value</code>。如果不存在，则会调用<code>addEntry()</code>方法。进入<code>addEntry()</code>方法，同样判断了<code>size &gt;= threshold</code>，不过此处与前者也有不同。前者会将新添加的元素插入后才进行扩容，而后者则先进行了扩容才将新添加的元素重新计算才插入链表，所以导致前者判断的是<code>&gt;</code>而无<code>=</code>判断，即前者必须超过阈值才会扩容，后者则是达到阈值即扩容（后者扩容方法之后分析），如果算上还没添加的新元素的话，那其实后者也必定大于阈值了。代码向下读，不论是否需要扩容，此时都会调用<code>createEntry()</code>方法来创建新<code>Entry&lt;K,V&gt;</code>节点插入此链表中。进入<code>createEntry()</code>方法，我们看到插入逻辑简单粗暴，让此下标直接引用了这个新创建的<code>Entry&lt;K,V&gt;</code>。进入<code>Entry&lt;K,V&gt;</code>的构造方法我们看到，被传入的当前链表的头节点被新建<code>Entry&lt;K,V&gt;</code>的<code>next</code>属性引用，显而易见的后者插入节点是使用的<strong>头插法</strong>。此点也与前者完全不同。在分析前者时，我们还分析了前者的<code>hash()</code>方法，那我们也来看看后者的<code>hash()</code>方法吧。</p><h3 id="hash-1"><a href="#hash-1" class="headerlink" title="hash()"></a>hash()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> hashSeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，后者<code>hash()</code>方法比前者更加复杂。不过两者都是利用了位移运算来尽量让每位值都参与到<code>hash</code>算法中避免哈希碰撞。这里可以得出结论：两者的<code>hash()</code>算法不同。最后我们再来看看最重要的方法，<code>resize()</code>方法。</p><h3 id="resize-1"><a href="#resize-1" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key); <span class="comment">// 重新计算hash值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>resize()</code>方法无非就是将原来数组内的元素全部添加到新的数组中，但是前者不会去重新计算<code>hash</code>值（此处我们已经讲得很详细），而后者会通过<code>rehash</code>来重新计算。至此，我们有关<code>JDK1.7</code>源码中的<code>HashMap</code>也粗略的过了一遍了。最后，我们再来总结下这两者有什么不同。</p><h2 id="总结JDK1-8与JDK1-7的异同"><a href="#总结JDK1-8与JDK1-7的异同" class="headerlink" title="总结JDK1.8与JDK1.7的异同"></a><span id="sums">总结JDK1.8与JDK1.7的异同</span></h2><ol><li>在<code>JDK1.8</code>中，<code>HashMap</code>的数据结构为 <strong>数组 + 链表 + 红黑树</strong> 。而在<code>JDK1.7</code>中，数据结构仅为 <code>数组 + 链表</code>。这导致有关红黑树结构属性、常量、方法在<code>JDK1.7</code>中都不具备。</li><li>两者的节点类型不同。在<code>JDK1.8</code>中节点类型是<code>Node&lt;K,V&gt;</code>或<code>TreeNode&lt;K,V&gt;</code>，而在<code>JDK1.7</code>中为<code>Entry&lt;K,V&gt;</code>。</li><li>两者的<code>hash()</code>算法不同，且<code>JDK1.7</code>中会发生<code>rehash</code>重新计算哈希值。</li><li>两者在扩容<code>resize()</code>方法处理细节不同。<code>JDK1.8</code>中会先“插入”再扩容，而<code>JDK1.7</code>中则先扩容再<code>rehash</code>后插入。 </li><li>两者加入元素的方式不同，<code>JDK1.8</code>加入链表是“尾插法”，而<code>JDK1.7</code>则使用<code>头插法</code>。这直接导致<code>JDK1.7</code>在多线程情况下扩容时可能导致链表“成环”而死循环，<code>JDK1.8</code>修复了这点。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的&lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;JDK1.8&lt;/code&gt;之前的&lt;code&gt;HashMap&lt;/code&gt;来做比较。今天我将通阅读基于&lt;code&gt;JDK1.8&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;与&lt;code&gt;JDK1.7&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;的源码来与大家做一个分享。  &lt;/p&gt;
&lt;p&gt;我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。&lt;strong&gt;这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。&lt;/strong&gt;当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳&lt;code&gt;JDK1.8&lt;/code&gt;中的&lt;code&gt;HashMap&lt;/code&gt;&lt;a href=&quot;/2018/06/10/HashMap/#sum&quot;&gt;总结&lt;/a&gt;查看，或者JDK1.8与JDK1.7的&lt;a href=&quot;/2018/06/10/HashMap/#sums&quot;&gt;异同&lt;/a&gt;查看对比。  &lt;/p&gt;
&lt;p&gt;最后，我的&lt;a href=&quot;/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/&quot;&gt;源码阅读&lt;/a&gt;系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。&lt;br&gt;那么，废话就不说了，大家跟着我一起来阅读源码吧。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://www.hellozuofeng.cn/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码" scheme="https://www.hellozuofeng.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="https://www.hellozuofeng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
