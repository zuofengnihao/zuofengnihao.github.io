<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TAKO</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-12T20:18:37.609Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>老板是只叫JOE的猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>源码解读——AbstractQuenedSynchronizer</title>
    <link href="http://example.com/2021/02/13/aqs/"/>
    <id>http://example.com/2021/02/13/aqs/</id>
    <published>2021-02-12T17:02:08.000Z</published>
    <updated>2021-02-12T20:18:37.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>内容</p><hr><h2 id="初看"><a href="#初看" class="headerlink" title="初看"></a>初看</h2><p>内容</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;内容&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初看&quot;&gt;&lt;a href=&quot;#初看&quot; class=&quot;headerlink&quot; title=&quot;初看&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>源码解读——HashMap</title>
    <link href="http://example.com/2018/06/10/HashMap/"/>
    <id>http://example.com/2018/06/10/HashMap/</id>
    <published>2018-06-10T02:22:30.000Z</published>
    <updated>2018-06-11T07:31:38.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的<code>HashMap</code>和<code>JDK1.8</code>之前的<code>HashMap</code>来做比较。今天我将通阅读基于<code>JDK1.8</code>的<code>HashMap</code>与<code>JDK1.7</code>的<code>HashMap</code>的源码来与大家做一个分享。  </p><p>我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。<strong>这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。</strong>当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳<a href="/2018/06/10/HashMap/#sums">总结</a>查看。  </p><p>最后，我的<a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a>系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。<br>那么，废话就不说了，大家跟着我一起来阅读源码吧。</p><a id="more"></a><h2 id="JDK1-8中的HashMap"><a href="#JDK1-8中的HashMap" class="headerlink" title="JDK1.8中的HashMap"></a>JDK1.8中的HashMap</h2><p>每个人都又不同的阅读耐心。为了能让耐心不够的同学，可以在更有效的时间内记住更重要的内容，所有我们从优化更好的、使用率更高的1.8版本的HashMap开始阅读！  </p><p>那么我们来<code>new HashMap()</code>，跟着无参构造函数进入源码。</p><h3 id="new-HashMap"><a href="#new-HashMap" class="headerlink" title="new HashMap()"></a>new HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在<span id="con">无参构造函数</span>中，源码只是设置了属性<code>loadFactor</code>的值为一个<code>DEFAULT_LOAD_FACTOR</code>的常量。此时我们碰到了第一个属性和第一个常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 第一个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 第一个常量 </span></span><br></pre></td></tr></table></figure><p>可以看出这<code>DEFAULT_LOAD_FACTOR</code>常量是<code>loadFactor</code>属性的默认值（<code>0.75</code>），但暂时没有其他信息，让我们记住这个属性和常量的值。既然源码只是初始化了一下一个属性，那么我进入<code>put()</code>方法。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>put()</code>方法中，我们看到<code>key</code>被传入了<code>hash()</code>方法。显然这是一个获取<code>key</code>hash值的算法。那么我们来看1.8中是如何计算key的hash值的。  </p><h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a><span id="hash">hash()</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// key==null时返回hash值0，否则调用hashCode()获取hash值并异或此hash高位并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个<code>HashMap</code>中的静态的不可重写的方法，返回一个<code>int</code>类型的hash值。当传入的<code>key</code>是<code>null</code>时，直接返回了值<code>0</code>。由此我们可以得到源码阅读的第一条结论，<strong>HashMap在jdk1.8中可以存放key为null的键值对，且key为null时的hash值即<code>0</code>。</strong><br>继续向下看，源码中，<code>key</code>调用了<code>Object</code>的<code>hashCode()</code>方法获取到了一个Hash值，再和此hash值的<a href="#high">高位</a>进行了一个异或<code>^</code>运算。这样做的目的是什么呢？为什么不直接返回<code>Object</code>中<code>hashCode()</code>的值呢？这里我们暂时记住它，我们回到<code>put()</code>方法继续往下看，源码中调用了<code>putVal()</code>方法。</p><blockquote><p><span id="high"><code>&gt;&gt;&gt; 16</code></span>表示无符号右位移16位运算，<code>int</code>类型有32位的长度，右位移16位即截取了此<code>int</code>值的左边16位的值，而所谓“左边16位”是口语化的说法，身为程序员，应该知道，平时我们称此为“高位”，而对应的“右边16位”我们称“低位”，如果要截取低位的值，可以使用<code>&amp; 0x0000FFFF</code>的运算获得。这样的“位运算”是基础知识，此篇文章就不再详细介绍了，如果不懂可以自行google或baidu。  </p></blockquote><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//判断table是否被初始化</span></span><br><span class="line">        <span class="comment">// table未被初始化时</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// resize()方法中初始化Node数组</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// hash值与数组长度模获取下标，再获获取tab对应此下标的Node</span></span><br><span class="line">            <span class="comment">// 当此下标下的Node为null，已进加入元素（key,value）创建Node并赋值到此下标</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当此下标的Node不为空时</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断获取到的Node中的元素与新加入的元素（key,value）是否为同一元素</span></span><br><span class="line">                e = p; <span class="comment">// 当此Node中元素与新加入元素为同一元素时，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断获取到的Node是都为 红黑树结构</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">// 如果获取的Node是红黑树结构时，将新加入的元素创建TreeNode并添加至红黑树，赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 当此Node为链表结构且Node中元素与新加入的元素不为同一元素时</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 循环此Node链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//判断链表是否含有后继节点（next是否为null）其用意是判断该节点是否已经是尾部节点</span></span><br><span class="line">                        <span class="comment">// 当next=null时，无后继节点时，即当前节点已经是尾节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 将新加入的元素创建新Node赋值给当前Node（尾节点）的next，即让新加入的元素成为尾节点（尾插法）。</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st 判断链表的长度是否超过阈值（默认值8）</span></span><br><span class="line">                            treeifyBin(tab, hash);<span class="comment">// 当链表的长度超过阈值则将整个</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>putVal()</code>方法，代码读到<code>if ((tab = table) == null || (n = tab.length) == 0)</code>（行号4），第二个属性<code>table</code>出现。此属性的类型是一个静态内部类<code>Node&lt;K,V&gt;</code>的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 第二个属性table 链表数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类，链表的节点类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 省略set、get等方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很显然，这个静态内部类是一个链表的节点类型，并且此链表是一个单向链表（只有next，无pre）。那此行代码的用意就在于判断<code>table</code>是否已经被初始化了。记得吗？我们在<a href="#con">构造函数</a>中，只初始化了一个参数<code>loadFactor = DEFAULT_LOAD_FACTOR = 0.75f</code>，那么代码到<code>n = (tab = resize()).length</code>（行号6）。<code>resize()</code>方法应该会初始化节点数组<code>node&lt;K,V&gt;[] table</code>（从代码逻辑可以看出，不初始化下面的逻辑将无法继续）。而这个<code>table</code>就是一个链表数组，那么，我们可以暂时得到结论：<strong>HashMap是数组加链表的数据结构，并且这个数组是在第一次put()时才被初始化</strong>。我们先把<code>resize()</code>方法放一放，继续向下读。  </p><p>代码来到<code>if ((p = tab[i = (n - 1) &amp; hash]) == null)</code>（行号7），这里是使用元素的<code>hash</code>值来计算数组下标。按照我们平时的逻辑，我们一般会用<code>hash</code>值去与数组长度<code>n</code>取模来获取定位此元素在数组中的位置，这样也利用了<code>hash</code>值且不会发生<code>ArrayIndexOutOfBoundsException</code>（数组下标越界）。而源码中是<code>(n - 1) &amp; hash</code>方式来定位下标。其实，源码是使用了效率更高的位运算方法来<a href="#qumo">取模</a>的。现在我们知道了如何定位数组下标的，回到<a href="#hash">之前</a><code>hash()</code>方法。为什么要用高位去与上低位呢？目的是为了减少哈希碰撞（降低下标值相等的概率）。试想一下，如果我们获取到是<code>hash</code>值都是<code>1101 0000</code>、<code>1000 0000</code>、<code>1010 0000</code>等这种低位值都“相似”的值，而这些值去与上同一个值（数组长度）且这个值也不大（比如<code>0000 1010</code>），势必我们得到的结果就会一样了，即发生了哈希碰撞。为了减少哈希碰撞，那么，我们就得想办法，让高位也参与到运算中。<strong>因此，源码中使用让低位与上高位这样的操作，目的是让高位参与到取模运算中来，以避免哈希碰撞</strong>。  </p><p>我们继续往下读，<code>tab[i] = newNode(hash, key, value, null)</code>（行号9）。这行代码就是当此下标元素为空时，直接将我们这个新put进来的元素构造成Node&lt;K,V&gt;赋值给了此下标（情况如下图）。</p><p>那么，当我们此下表下已经存在链表了，会是什么情况呢？<code>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code>（行号13和14），如果存在链表了，会先判断我们新加入的元素和此链表的第一个Node&lt;K,V&gt;节点是否为同一元素，即判断它们的Hash值和key是否一致。如果新加入的元素是同一元素，那么很好办，将新值value替代老值即可。代码继续向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>这是单项链表的节点类型（<a href="#transient">transient关键字的意义</a>）。我们常说，<code>HashMap</code>是<strong>数组加链表</strong>的数据结构，链表就是静态内部类<code>Node&lt;K,V&gt;</code>，数组则是<code>Node&lt;K,V&gt;</code>节点类型的数组了。源码继续往下，此时是判断了此属性<code>table</code>是否为空或长度为0。还记得吗？我们在构造函数中，并没有初始化这个<code>table</code>的值，<code>resize()</code>方法一定生成了<code>Node&lt;K,V&gt;[]</code>数组，而望文生义，这个方法的名字已经告诉我们，这是一个数组“扩容”的方法。  </p><blockquote><p>被<span id="transient"><code>transient</code></span>关键字修饰的属性不会别序列化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// oldCap = 0;因为table=null</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// oldThr = 0;因为threshold未在构造中初始化，那么它的默认值（int类型）即为0 </span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        ...; <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// newCap = DEFAULT_INITIAL_CAPACITY = 16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// newThr = 0.75 * 16 = 12  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        ...; <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// threshold = newThr = 12</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>resize()</code>方法，我们先省略当前逻辑无关的代码。此时就是初始化了一个<code>Node&lt;K,V&gt;[]</code>数组，这个数组的长度是<code>16</code>。并且，我们又看到了一个新的属性<code>threshold</code>和一个新的常量<code>DEFAULT_INITIAL_CAPACITY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16 第二个常量</span></span><br></pre></td></tr></table></figure><p>现在我已经知道<code>DEFAULT_INITIAL_CAPACITY</code>常量就是数组的默认初始化长度。回到<code>putVal()</code>方法继续往下看。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 通过hash值与数组长度取模，获取下标</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 创建Node并赋值到计算出来的下标中 </span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ...<span class="comment">// 省略非代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// modeCount = 0 + 1 = 1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// size = 0 + 1 = 1</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们已经初始化了<code>Node&lt;K,V&gt;[]</code>数组，但是还没有添加任何元素。那么，新put()的元素该往这个数组的哪个位置（下表index）赋值呢？按照，我们平时的逻辑，我们会用<code>hash</code>值去根据数组的长度去取模，以免发生<code>ArrayIndexOutOfBoundsException</code>（数组下标越界）。而源码中是<code>(n - 1) &amp; hash</code>方式来定位下标。其实，源码是使用了效率更高的位运算方法来<a href="#qumo">取模</a>的。现在我们知道了如何定位数组下标的，回到<a href="#hash">之前</a><code>hash()</code>方法。为什么要用高位去与上低位呢？目的是为了减少哈希碰撞（降低下标值相等的概率）。试想一下，如果我们获取到是<code>hash</code>值都是<code>1101 0000</code>、<code>1000 0000</code>、<code>1010 0000</code>等这种低位值都是相等的值，而这些值去与上<code>1010</code>、<code>101</code>、<code>1001</code>这样不大的值，势必我们得到的结果就会一样了。为了减少哈希碰撞，那么，我们就得想办法，让高位也参与到运算中。<strong>因此，源码中使用让低位与上高位这样的操作，目的是让高位参与到取模运算中来，以避免哈希碰撞。</strong>  </p><p>代码继续向下阅读，我们看到了第三个属性<code>modCount</code>和第四个属性<code>size</code>。显然，<code>size</code>是表示当前的元素个数的，而<code>modCount</code>暂时还不知道其用意，这里也暂且记下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 第四个属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">// 第五个属性</span></span><br></pre></td></tr></table></figure><p>继续向下阅读，当元素个数大于之前我们的保存的属性<code>threshold</code>时，就会发生<code>resize()</code>扩容了。所以，我们可以得到结论，<code>threshold</code>属性就是<strong>发生扩容的长度阈值</strong>，而<code>DEFAULT_LOAD_FACTOR</code>与<code>DEFAULT_INITIAL_CAPACITY</code>常量，前者是<strong>默认扩容因子0.75</strong>，后者我们刚已经得到的结论，是默认的数组长度。此时我们虽然是第一次向<code>HashMap</code>中put()元素，如果此时已经超过了阈值呢？我们再次进入<code>resize()</code>方法仔细来看看，<code>HashMap</code>是如何扩容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><span id="qumo">取模</span>小技巧 <code>val % 2^n = val &amp; (2^n - 1)</code>。在<code>HashMap</code>中，数组的长度是必定是2^n。</p></blockquote><h2 id="JDK1-7中的HashMap"><a href="#JDK1-7中的HashMap" class="headerlink" title="JDK1.7中的HashMap"></a>JDK1.7中的HashMap</h2><p>内容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="sums">总结</span></h2><p>内容</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;我们时常在面试时被问及HashMap相关问题，也时常拿JDK1.8之后的&lt;code&gt;HashMap&lt;/code&gt;和&lt;code&gt;JDK1.8&lt;/code&gt;之前的&lt;code&gt;HashMap&lt;/code&gt;来做比较。今天我将通阅读基于&lt;code&gt;JDK1.8&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;与&lt;code&gt;JDK1.7&lt;/code&gt;的&lt;code&gt;HashMap&lt;/code&gt;的源码来与大家做一个分享。  &lt;/p&gt;
&lt;p&gt;我会以我阅读源码的习惯，从构造函数开始，一步一步的来分析HashMap的属性与方法，或者说内部类。不会和其他文章博客一样，开篇就向大家抛出所有属性、方法或内部类。&lt;strong&gt;这也是我的博客相比其他博客不同之处，以一个正常阅读源码的顺序一步步刨析源码，等遇到某个属性，某个方法，某个常量时，我们再根据代码逻辑来分析这些个属性、常量、方法的用意。&lt;/strong&gt;当然，最后阅读完成之后，会有一个总结，如果大家觉得看得太墨迹，可以直接跳&lt;a href=&quot;/2018/06/10/HashMap/#sums&quot;&gt;总结&lt;/a&gt;查看。  &lt;/p&gt;
&lt;p&gt;最后，我的&lt;a href=&quot;/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/&quot;&gt;源码阅读&lt;/a&gt;系列将一直持续下去。更新可能不频繁，但文章内容肯定是深入浅出，争取让所有的同学都看得懂。&lt;br&gt;那么，废话就不说了，大家跟着我一起来阅读源码吧。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
