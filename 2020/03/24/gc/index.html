<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hellozuofeng.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引子此篇文章的诞生是因为每次在新项目上线设置参数时，自己总要回头复习一遍垃圾收集器好来确定新项目上线时该如何选择。正好因为疫情原因，宅家里读完了再版的《深入理解Java虚拟机》（第三版 2019.12月再版）。这次我将常用的垃圾收集器做一个集中汇总总结，方便自己查阅的同时也方便大家查阅。同时在此感谢周志明老师再版《深入理解Java虚拟机》。但是有关书中“3.4.6 并发的可达性分析”这个小章节，我">
<meta property="og:type" content="article">
<meta property="og:title" content="GC垃圾收集知识点汇总">
<meta property="og:url" content="https://www.hellozuofeng.cn/2020/03/24/gc/index.html">
<meta property="og:site_name" content="TAKO">
<meta property="og:description" content="引子此篇文章的诞生是因为每次在新项目上线设置参数时，自己总要回头复习一遍垃圾收集器好来确定新项目上线时该如何选择。正好因为疫情原因，宅家里读完了再版的《深入理解Java虚拟机》（第三版 2019.12月再版）。这次我将常用的垃圾收集器做一个集中汇总总结，方便自己查阅的同时也方便大家查阅。同时在此感谢周志明老师再版《深入理解Java虚拟机》。但是有关书中“3.4.6 并发的可达性分析”这个小章节，我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/1.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/2.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/3.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/4.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/5.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/9.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/10.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/11.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/16.jpg">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/12.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/13.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/14.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/15.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/17.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/18.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/19.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/6.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/7.png">
<meta property="og:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/8.png">
<meta property="article:published_time" content="2020-03-24T13:52:11.000Z">
<meta property="article:modified_time" content="2021-03-05T19:20:41.208Z">
<meta property="article:author" content="老板是只叫JOE的猫">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="GC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hellozuofeng.cn/2020/03/24/gc/1.png">

<link rel="canonical" href="https://www.hellozuofeng.cn/2020/03/24/gc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GC垃圾收集知识点汇总 | TAKO</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TAKO" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TAKO</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.hellozuofeng.cn/2020/03/24/gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="老板是只叫JOE的猫">
      <meta itemprop="description" content="不满足是向上的齿轮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TAKO">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GC垃圾收集知识点汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-24 21:52:11" itemprop="dateCreated datePublished" datetime="2020-03-24T21:52:11+08:00">2020-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">Java虚拟机</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>此篇文章的诞生是因为每次在新项目上线设置参数时，自己总要回头复习一遍垃圾收集器好来确定新项目上线时该如何选择。正好因为疫情原因，宅家里读完了再版的《深入理解Java虚拟机》（第三版 2019.12月再版）。这次我将常用的垃圾收集器做一个集中汇总总结，方便自己查阅的同时也方便大家查阅。同时在此感谢周志明老师再版《深入理解Java虚拟机》。但是有关书中“3.4.6 并发的可达性分析”这个小章节，我在周老师原文基础上，写了大量自己的理解。因为第一次看第二版时，看到此章节的时候，确实有点稀里糊涂一知半解，现在已经经过自我消化和理解弄懂了。如果有部分同学同样也没看懂的可以仔细阅读本文中<a href="/2020/03/24/gc/#concurrent">并发标记</a>的章节。当然，如果我有理解错误的地方还请大家指正。</p>
<a id="more"></a>

<h2 id="何为垃圾"><a href="#何为垃圾" class="headerlink" title="何为垃圾"></a>何为垃圾</h2><p>一个“对象”，我们该如何判断是否是垃圾对象呢？按逻辑来说，我们认为不会再被访问的“对象”就是垃圾对象了，那它就是可以被回收的对象。那JVM要确定一个“对象”不会再被访问，只要确定这个“对象”没有被引用即可。为了确定“对象”是否被引用，出现了不同的确定算法，下面我们分别介绍。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>这个算法实现很简单。在对象中添加一个“引用计数器”，只要“对象”被引用一次，我们就让计数器的值<code>+1</code>。当一个引用失效，就让计数器的值<code>-1</code>。只要计数器的值为<code>0</code>则表示没有任何引用，即表示对象可以被回收了。虽然算法简单粗暴效率高，但是一旦多个“对象”之间相互引用，同时这些对象无其他引用的话，这两个对象将会永远无法被正确回收从而导致了“内存泄漏”。看看下图中的示例大家就明白了。</p>
<p><img src="/2020/03/24/gc/1.png" alt="1"></p>
<p>在上图中，<code>A</code>对象被栈中的<code>a</code>变量所引用，<code>D</code>对象被常量池中的<code>d</code>所应用。这两个对象引用计数器的值为<code>1</code>，这是理想情况下正确的引用，对象也被标记为“存活”这没有异议。而对象<code>F</code>没有被任何变量所引用，引用计数器的值是<code>0</code>，它理应是被标记为“死亡”。但是对象<code>B C E</code>三者之间，都是互相引用的，<code>B</code>对象中有变量<code>e</code>引用<code>E</code>对象；<code>E</code>对象中有变量<code>c</code>引用<code>C</code>对象；而<code>C</code>对象中有变量<code>b</code>又引用<code>B</code>对象；而且没有其他变量引用这三个对象。它们形成了一个闭环，并且他们各自的引用计数器的值都是<code>1</code>，会被标记成“存活”，这就造成了“内存泄漏”。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。同样，我们也看看下图的示例。</p>
<p><img src="/2020/03/24/gc/2.png" alt="2"></p>
<p>上图中，我们删去了“引用计数器”，并将<code>a</code>和<code>b</code>标记为了“GC Root”。只要在“GC Root”这个引用链上的对象，我们都认为是“存活”对象。相反，不在引用链上的对象，不论你如何被引用都会视为“死亡”对象。这就很号解决了“引用计数法”中对象相互引用的而导致的“内存泄漏”。而我们的JVM标记垃圾对象的算法也就是使用的“可达性分析法”。那问题来了，我们要将哪些对象标记为“GC Root”对象呢？从上图中，已经给出了两个答案。一个是常量池中被引用的对象，二是运行中的线程中被引用的对象。大家想想还没有呢？ 下面我将“GC Root”对象做了总结。  </p>
<p>GC Root：</p>
<ul>
<li>在虚拟机栈(本地变量表)中引用的对象</li>
<li>在方法区中类静态属性引用的对象</li>
<li>在方法区中常量引用的对象</li>
<li>在本地方法栈中JNI(Native方法)引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象 一些常驻的异常对象(NullPoint,OOM),还有系统类加载器</li>
<li>反映Java虚拟机部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<h2 id="如何清理"><a href="#如何清理" class="headerlink" title="如何清理"></a>如何清理</h2><p>在弄清楚了如何标记“垃圾”后，我们就得想想如何清理这些被“可达性分析法”标记的“垃圾”对象了。每个垃圾收集器，都具有自己不同的垃圾回收算法，但是有着共同的思想，那就是“分代收集”理论。设计者一般至少会把Java堆划分成新生代和老年代两个区域。在新生代中，大部分对象都会死去，而每次存活的少量对象将会逐步晋升到老年代中。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分“标记”与“清除”两个阶段：首先标记所有需要回收的对象（也可以标记存活对象），标记完成后，统一回收掉所有被标记的对象（标记的是存活对象则清除未被标记的对象）。它是最基础的收集算法，后续的算法大多都是以此算法为基础，对其缺点进行改进的算法。下图为标记-清除算法的执行过程。</p>
<p><img src="/2020/03/24/gc/3.png" alt="3"></p>
<p>大家见到上图，应该会发现，这个算法有个明显的缺点：那就是会导致内存空间碎片化。还有一个缺点就是效率不稳定，会随着对象数量的增加而降低效率。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决标记-清除算法的效率问题，诞生了标记-复制算法。它将可用内存按容量分成大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将“存活”的对象复制到另外一块内存上，再把自己这一块内存一次清理掉。其过程如下图所示。</p>
<p><img src="/2020/03/24/gc/4.png" alt="4"></p>
<p>可以看到，上面空间碎片化的问题被标记-复制算法给很好的解决了。但是关于效率问题，如果“存活对象”比较少，那么效率是可以得到保证的。但是存活对象比较多，那么就会将会产生大量的内存间复制的开销。所以此方法比较适用与新生代，因为新生代大部分对象都是朝生夕死的对象。当然，此方法还有一个明显的缺点，就是可用内存只有实际内存的一半，降低了内存使用效率。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>既然标记-复制算法比较适合新生代，那老年代我们应该选择何种算法呢？那么来看看标记-整理算法。其算法也是在标记-清除算法上多做了一件事，那就是清除后进行了内存的整理,将存活的对象向内存空间一端移动。其过程如下。</p>
<p><img src="/2020/03/24/gc/5.png" alt="5"></p>
<p>标记-清除与标记-整理算法本质上的差异在于前者是一种非移动式的，后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。那么，我们看看这些商用垃圾收集器都是使用的哪些算法来完成垃圾收集吧。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>上面我们已经介绍了“定位”和“清理”一些理论算法，那我们Hotspot在实现这些算法时，是如何保证高效运行的呢？那么我们现在来介绍一些算法上的实现细节。</p>
<h3 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h3><p>首先要解决的是，我们每次在定位GC Roots时，如何每次都去扫描整个方法区和所有栈内的引用必将是一个耗时的工作。于是工程师们设计了<code>OopMap</code>的数据结构，在类加载动作完成的时候会记录方法区里的对象引用信息，在即时编译过程中也会在特定位置记录栈中的对象引用信息。这样一来，虚拟机就可以通过<code>OopMap</code>快速定位GC Roots。那么什么是特定位置呢？在阐述特定位置前，我们来谈一个前提。程序在运行中，对象的引用关系是不断变化的，而我们必须保证我们的GC Roots不能遗漏，否则回收掉了我们还需使用的对象程序必将崩溃。所以，现在所有的垃圾收集器在枚举GC Roots时都是会暂停掉我们的用户线程，这就是我们所说的“Stop the world”。回到特定位置的阐述，我们在每个指令的时候都去生成<code>OopMap</code>显然是不合适的，这样不但浪费内存，还占用Cpu资源（引用不断变化）。所以我们生成<code>OopMap</code>应在一个比较“安全”的时段生成是比较合适的，那么这个“安全”的时段我们就称其“安全点”（安全域）。此时用户线程被暂停，引用不发生改变，虚拟机将上次安全点到此次安全点这段时间引用发生的改变来记录<code>OopMap</code>再合适不过了。</p>
<h3 id="RememberSet"><a href="#RememberSet" class="headerlink" title="RememberSet"></a>RememberSet</h3><p>我们大部分垃圾收集器都使用了分代收集的思想，我们通过<code>OopMap</code>解决了GC Roots的枚举，当我们只回收新生代时，只要在<code>OopMap</code>中找到新生代的引用做为GC Roots，使用“可达性分析”算法定位所有应该存活的对象，再将这些对象复制到一块Survive区域中，同时清空Eden与另一块Survive区域，就完成了一次新生代的垃圾收集。但是有一个问题，那就是如果我们新生代中有些对象没有在GC Roots的引用链上，但在老年代某个对象的引用链上，那我们应该把这个老年代的对象也加入到我们的GC Roots中。那我们是如何记录这种跨代引用关系呢？于是工程师们设计了一个“记忆集”（RememberSet）的数据结构，来记录跨代引用关系。关于记忆集根据其记录精度（字长精度、对象精度、卡精度）多种实现方式，在我们虚拟机中使用的是“卡表”（卡精度）来实现的。卡表中每个元素都是一块内存区域标识，这个内存块叫“卡页”。卡页内只要有一个对象字段存在跨代指针，那么这元素就变脏，值标为0。在垃圾收集的时候，只要把变脏的元素对应的这块内存区域的一起加入GC Roots中一并扫描就能解决跨代收集的问题。但是如何让其变脏？很简单，就是利用赋值时插入“写屏障”来实现。我们可以将“写屏障”看作织入“赋值”操作这个切面的环绕通知，更新“卡表”的工作就在通知中完成。</p>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><span id="concurrent">并发标记</span></h3><p>我们知道，很多垃圾收集器是在暂停用户线程“Stop the world”的情境下来完成标记，直至CMS收集器的出现。试想一下，用户线程与标记过程一起并发的话，会有两种情况出现：</p>
<ol>
<li>应该被标记存活的对象没有标记；</li>
<li>应该清理的对象被误标记了存活。  </li>
</ol>
<p>这两种情况中，第二种还是能够容忍的，只要之后的垃圾收集过程将其清理就行了。但是第一种情况是完全不能接受的。那么我们利用“三色标记”来进行“可达性分析”，看看出现第一种情况有哪些原因。  </p>
<p>所谓三色标记法：</p>
<ul>
<li>白色表示还未被垃圾收集器访问过的对象，所以当垃圾收集线程还未开始执行时，所有对象都是白色；</li>
<li>黑色表示已经被垃圾收集器访问过的对象，且这个对象中所有引用了的对象都已经被访问，所以黑色对象就是“存活”对象，并且再重新标记过程中不再扫描此对象；</li>
<li>灰色对象是垃圾收集已经开始访问，但还没有访问完被此对象所引用对象;  </li>
</ul>
<p>此处说法与《深入理解Java虚拟机》书中描述有所区别，但实际上是同样的意思，大家将其看做一个过程比较好理解。下面我将画图来说明此过程。</p>
<p><img src="/2020/03/24/gc/9.png" alt="9"></p>
<p>上图中所有对象都是白色，此刻是我们开始“标记”线程时，内存的初始状态。现在我们GC线程开始执行“标记”过程，运行到下图状态。  </p>
<p><img src="/2020/03/24/gc/10.png" alt="10"></p>
<p>此图状态是垃圾收集器沿着GC Root访问到对象<code>C</code>时的状态。此刻<code>C</code>对象刚开始访问变色为灰色；<code>A</code>和<code>B</code>对象已经访问完毕，且它们对象中引用的其他对象也已经访问（<code>A</code>中引用<code>B</code>，<code>B</code>已经被访问；<code>B</code>中引用了<code>C</code>，<code>C</code>开始了访问），所以<code>A</code>和<code>B</code>变为黑色。  </p>
<p>如果此刻用户线程修改了引用关系，将<code>B</code>对象添加了引用指向<code>D</code>对象，并且删除了<code>C</code>对象中对<code>D</code>对象的引用，最后完成“可达性分析”遍历，就会导致下图结果。</p>
<p><img src="/2020/03/24/gc/11.png" alt="11"></p>
<p>当遍历完成，对象<code>D</code>应该被标记成黑色的“存活”对象，但是由于用户线程操作，使得它将会被错误的清理。大家发现没有，我们现在可以得到结论：导致这样的情况是必须具备两个<span id="condition">条件</span>的：</p>
<ol>
<li>黑色对象新建了一个引用指向白色对象。</li>
<li>这个白色对象必须不在灰色对象引用链中。  </li>
</ol>
<p>也就是我们之前两步操作：</p>
<ul>
<li>将<code>B</code>对象添加了引用指向<code>D</code>对象</li>
<li>删除了<code>C</code>对象中对<code>D</code>对象的引用    </li>
</ul>
<p><strong>这里大家注意下，我所有操作顺序都是先建立新引用关系，再删除旧引用关系</strong>。这个和《深入理解Java虚拟机》举例子有所不同，如下图。  </p>
<p><img src="/2020/03/24/gc/16.jpg" alt="16"></p>
<p>但我个人认为这很重要，我将会在下面一种<a href="#impossible">“不可能发生的情况”</a>（这个不可能不是绝对，有两种情况是有可能的，请大家耐心往下看）中做说明。再回到主题，为了更直观的感受两个条件缺一不可，那么我们分别画图举例说明。</p>
<p><img src="/2020/03/24/gc/12.png" alt="12"></p>
<p>上图中，我们只是将<code>B</code>对象添加了引用指向<code>D</code>对象这样的操作。当遍历完成之后，由于<code>C</code>对象还引用着<code>D</code>对象，所以收集器任然可以遍历到<code>D</code>对象，最终<code>D</code>对象还是会被正确标记为黑色。  </p>
<p><img src="/2020/03/24/gc/13.png" alt="13"></p>
<p>上图中，我们只是删除<code>C</code>对象中对<code>D</code>对象的引用这个操作。当遍历完成之后，<code>D</code>对象确实也不再存在于GC Roots的引用链中，被标记为白色只是正确删除了这个对象而已。  </p>
<p>至此，我们得出来的两个条件的结论是否已经成立了？相信有一部分同学，想到了还有一种<span id="impossible">情况</span>，那就是一个原本就不在GC Roots引用链中的对象被一个黑色对象引用了，这种情况有没有？如下图。  </p>
<p><img src="/2020/03/24/gc/14.png" alt="14"></p>
<p>上图中，初始内存多出了一个<code>F</code>对象，它并没有在GC Roots的引用链中。当遍历到<code>C</code>对象时，改变引用关系，将黑色对象<code>B</code>添加引用指向<code>F</code>对象。当遍历完成后，本应该被标记为黑色“存活”的对象<code>F</code>还是白色被清除的对象。看上去，这样分析是没有错的，但是大家想一想，这样的情况会出现吗？我先抛出结论，除开两种<span id="special">特例</span>：1.使用<code>Unsafe</code>类；2.这个对象是刚刚新建出来的。除以上两种特殊的情况，这样的情况是不会出现的。下面我们就举个例子来说明为什么不可能，之后再来讨论第二个特例（特例一使用<code>Unsafe</code>类就不讨论了，一般不会使用它来获取内存地址，如果你非要使用出了问题也是自己负责，毕竟别人都告诉你Unsafe了，哈哈哈哈）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MyObject next;</span><br><span class="line">    <span class="keyword">public</span> MyObject other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们创建了一个<code>MyObject</code>类。这个类中有两个<code>MyObject</code>类型的属性<code>next</code>和<code>other</code>（这里我们只设置两个属性已经够用）。我们在<code>main()</code>方法中，将上图中的<code>A</code>到<code>F</code>对象都创建出来并将其建立引用关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject a = <span class="keyword">new</span> MyObject(); <span class="comment">// A对象</span></span><br><span class="line">    a.next = <span class="keyword">new</span> MyObject(); <span class="comment">// B对象</span></span><br><span class="line">    a.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// C对象</span></span><br><span class="line">    a.next.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// D对象</span></span><br><span class="line">    a.next.next.other = <span class="keyword">new</span> MyObject(); <span class="comment">// E对象</span></span><br><span class="line">    <span class="keyword">new</span> MyObject(); <span class="comment">// F对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家发现了吧，我们的<code>F</code>对象确实会被创建出来，但是它没有赋值给任何变量，这种情况下，请问如何能让<code>B</code>对象来与其建立联系呢？也就是说我们没有变量就不知道<code>F</code>对象的内存地址，不知道内存地址就无法让<code>B</code>对象与其建立引用关系。而我之前为什么要强调先新增黑色对象指向白色对象的引用，再删除灰色对象对此白色对象的引用也是这个道理（如下所见）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject a = <span class="keyword">new</span> MyObject(); <span class="comment">// A对象</span></span><br><span class="line">    a.next = <span class="keyword">new</span> MyObject(); <span class="comment">// B对象</span></span><br><span class="line">    a.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// C对象</span></span><br><span class="line">    a.next.next.next = <span class="keyword">new</span> MyObject(); <span class="comment">// D对象</span></span><br><span class="line">    a.next.next.other = <span class="keyword">new</span> MyObject(); <span class="comment">// E对象</span></span><br><span class="line">    <span class="keyword">new</span> MyObject(); <span class="comment">// F对象</span></span><br><span class="line"></span><br><span class="line">    a.next.next <span class="comment">// 这里是获取C对象</span></span><br><span class="line">            .next = <span class="keyword">null</span>; <span class="comment">// 这里是删除C对象与D对象的引用关系</span></span><br><span class="line">    </span><br><span class="line">    a.next <span class="comment">// 这里是获取B对象</span></span><br><span class="line">        .other = a.next.next.next; <span class="comment">// 这里是准备将D对象与B对象建立联系 但是我们发现我们已经找不到D对象的引用（地址）了</span></span><br><span class="line">        <span class="comment">// 此时a.next.next.next 已经是 null 了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里大家应该懂了，为什么要先建立新引用再删除旧引用了吧。  </p>
<p>回到<code>F</code>对象的问题，有的同学会说那我们将<code>F</code>对象赋值给一个变量不就可以了，如<code>MyObject f = new MyObject()</code>。如果是这样的话，那变量<code>f</code>不应该也会在GC Root中了吗？（如下图）</p>
<p><img src="/2020/03/24/gc/15.png" alt="15"></p>
<p>最后，我们再来说说<a href="#special">第二种特殊情况</a>。我们都知道<code>MyObject f = new MyObject()</code>这其实不是一个<strong>原子操作</strong>。也就是说，是有可能出现新建的对象刚创建出来的时候还没有被赋值就发生了GC。此时<code>f</code>变量还没有值（即为<code>null</code>），而<code>F</code>对象也已经在内存中了。那<code>F</code>就会被标记成白色对象清理掉了。其实这样的情况是不会发生的，比如<strong>G1 在基于 SATB 实现的时候，针对新分配的对象，有一个专门的区域，所有该区域的对象都默认被标记为存活</strong>（SATB即原始快照，下面内容会涉及）。如果不是新分配对象，那么它就可以沿用上面陈述的逻辑：要么不在GC Roots的引用链中，我们也无法再找到这个对象的地址（除非使用Unsafe类）再赋值给GC Roots引用链中的对象；要么必定出现在GC Roots引用链中。至此，我们可以完满的证明了我们之前所得出的<a href="#condition">结论</a>。而在《深入理解Java虚拟机》书中归纳的内容即：</p>
<blockquote>
<p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色：<br>  *赋值器插入了一条或多条从黑色对象到白色对象的新引用；<br>  *赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
</blockquote>
<p>接下来，我们只要破坏其中一个条即可。由此分别产生了两个方案：增量更新和原始快照。  </p>
<ul>
<li><p>增量更新：这个方案还是很好理解的。它破坏的是第一个条件，黑色对象新增引用为白色对象时，就将这个引用记录下来，等并发扫描结束后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。我们还是以上图中的内存布局为例来说明。<br><img src="/2020/03/24/gc/17.png" alt="17"><br>可以看到，我们第一次遍历后，因为<code>B</code>对象新增了白色对象<code>D</code>引用，此时我们就记录下来。等第一遍历完毕，再以记录的这个黑色对象<code>B</code>为根，再遍历一次。从图中我们也可以看出，可以简单理解为<strong>黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了</strong>。</p>
</li>
<li><p>原始快照：这个方案相比上一个方案理解起来稍微有点难一点，笔者第一次阅读的时候就没弄懂。此处我会将我的理解写下，供大家参考。这个方案是破坏第二个条件，在有灰色对象删除与白色对象的引用时，我们要将这个引用记录下来。请注意，<strong>这里是将已经删除了的引用记录下来</strong>。比如，我们在以上的例子中，<code>C</code>对象删除了和<code>D</code>对象的引用，那我们记录下这个引用。然后在以<code>C</code>为根重新扫描一次。注意哦，这里实际上已经删除引用关系，可是按我们记录的内容重新扫描的。例子见下图。<br><img src="/2020/03/24/gc/18.png" alt="18"><br>这上面的图和文字大家没理解的话，可以慢慢消化（笔者自我感觉还是已经写的很清楚了）。如果理解了，大家会发现，这不和是我们按照“初始情况”来扫描的结果一样吗（即使改动了应用关系，我们也不理会）？如下图<br><img src="/2020/03/24/gc/19.png" alt="19"><br>没错，这就是原始快照的本意。似乎像是为我们“初始状态”创建了一个快照，不管之后引用关系如何改变，我们只按快照中的引用关系来遍历。但是，这样会出现一个问题，那就是产生“浮动垃圾”。之前我们也交代了，“浮动垃圾”并不是不可容忍的。只要以后的垃圾收集过程能将其清理就行了。至此，我们也可以简单的理解原始快照为<strong>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索</strong>。</p>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>下面这样图是我们将介绍的垃圾收集器。它们如何有连线则表示可以搭配使用，而所在区域说明了此款收集器的作用域。下面我们将以下收集器做下汇总介绍。</p>
<p><img src="/2020/03/24/gc/6.png" alt="6"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到它收集结束。下图是Serial（新生代收集器）搭配Serial Old（老年代收集器）运行流程。</p>
<p><img src="/2020/03/24/gc/7.png" alt="7"></p>
<p>虽然Serial已垂垂老矣，但其资源消耗比较小。对于一些内存容量有限，CPU核心数较少的单片机和或者是一些客户端的微服务来说，Serial仍然不失为一个好的选择。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为与Serial收集器完全一致。下图是ParNew（新生代收集器）搭配Serial Old（老年代收集器）运行流程。</p>
<p><img src="/2020/03/24/gc/8.png" alt="8"></p>
<p>ParNew收集器多数情况下是与CMS收集器搭配使用。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个并行的多线程新生代收集器，采用“标记-复制”算法。</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/GC/" rel="tag"># GC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/06/14/HashMap/" rel="prev" title="源码解读——HashMap">
      <i class="fa fa-chevron-left"></i> 源码解读——HashMap
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E5%9E%83%E5%9C%BE"><span class="nav-number">2.</span> <span class="nav-text">何为垃圾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">如何清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">标记-复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">标记-整理算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text">实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OopMap"><span class="nav-number">4.1.</span> <span class="nav-text">OopMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RememberSet"><span class="nav-number">4.2.</span> <span class="nav-text">RememberSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="nav-number">4.3.</span> <span class="nav-text">并发标记</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老板是只叫JOE的猫"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">老板是只叫JOE的猫</p>
  <div class="site-description" itemprop="description">不满足是向上的齿轮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://gitlab.com/zuofengnihao" title="GitLab → https:&#x2F;&#x2F;gitlab.com&#x2F;zuofengnihao" rel="noopener" target="_blank"><i class="fab fa-gitlab fa-fw"></i>GitLab</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/zuofengnihao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zuofengnihao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/zuofengnihao" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;zuofengnihao" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lao-ban-shi-yi-ge-jiao-joede-mao-48" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lao-ban-shi-yi-ge-jiao-joede-mao-48" rel="noopener" target="_blank"><i class="fab fa-quora fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老板是只叫JOE的猫</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">40k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36 分钟</span>
</div>
<div style="margin:0 auto;">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43010502001274" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="/images/beian.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">湘公网安备 43010502001274号</p></a>
	&nbsp;&nbsp;&nbsp;&nbsp;
	<a target="_blank" href="http://beian.miit.gov.cn/" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">互联网ICP备案：湘ICP备2021002469号</p></a>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
